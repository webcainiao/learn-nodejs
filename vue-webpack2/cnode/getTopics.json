{
  "success": true,
  "data": [{
    "id": "592f8ef01e7e75f60c1ad80d",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>此处发帖无限制，不会在首页展示，不影响用户正常使用，千万不要随便回复别人的帖子</p>\n</div>",
    "title": "此处发帖无限制，不会在首页展示，不影响用户正常使用，千万不要随便回复别人的帖子",
    "last_reply_at": "2017-06-01T14:26:26.012Z",
    "good": false,
    "top": true,
    "reply_count": 8,
    "visit_count": 214,
    "create_at": "2017-06-01T03:50:08.278Z",
    "author": {
      "loginname": "i5ting",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
    }
  }, {
    "id": "58ad76db7872ea0864fedfcc",
    "author_id": "51f0f267f4963ade0e08f503",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlwW5i2h_UuKpnBXXvD3AqyrwjHP\" alt=\"untitled4.png\"></p>\n<h1>饿了么大前端 Node.js 进阶教程</h1>\n<p>因为 2016 年面试了很多做 Node.js 的同学，发现大部分做 Node 的同学都是前端转过来的，对后端的知识大多一片空白。所以很难招到比较好的 Node.js 服务端程序员（注意，不是全栈）。</p>\n<p>于是出于我们一贯的开源与分享精神，我们筹备了这个名字叫《如何通过饿了么 Node.js 面试》的开源的 Node.js 进阶教程。</p>\n<p>github 仓库地址：<a href=\"https://github.com/ElemeFE/node-interview\">https://github.com/ElemeFE/node-interview</a></p>\n<h3>导读</h3>\n<p>本教程包含 2~3 年经验的 Node.js 服务端需要知道的知识点。</p>\n<p>需要注意的是, 并不适用于零基础的同学, 你需要有一定的 JavaScript/Node.js 基础, 并且有一定的工作经验. 另外本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分.</p>\n<p>稳重将一些常见的问题划分归类, 每类标明涵盖的一些<code>覆盖点</code>, 并且列举几个<code>常见问题</code>, 通常这些问题都是 2~3 年工作经验需要了解或者面对的. 如果你对某类问题感兴趣, 或者想知道其中列举问题的答案, 可以通过该类下方的 <code>阅读更多</code> 查看更多的内容.</p>\n<p>整体上大纲列举的并不是很全面, 细节上覆盖率不高, 很多讨论只是点到即止, 希望大家带着问题去思考.</p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">Js 基础问题</a></h2>\n<blockquote>\n<p>与前端 Js 不同, 后端是直面服务器的, 更加偏向内存方面.</p>\n</blockquote>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD\"><code>[Basic]</code> 类型判断</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E4%BD%9C%E7%94%A8%E5%9F%9F\"><code>[Basic]</code> 作用域</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92\"><code>[Basic]</code> 引用传递</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE\"><code>[Basic]</code> 内存释放</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#es6-%E6%96%B0%E7%89%B9%E6%80%A7\"><code>[Basic]</code> ES6 新特性</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>js 中什么类型是引用传递, 什么类型是值传递? 如何将值类型的变量以引用的方式传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-value\">[more]</a></li>\n<li>js 中， 0.1 + 0.2 === 0.3 是否为 true ? 在不知道浮点数位数时应该怎样判断两个浮点数之和与第三数是否相等？</li>\n<li>const 定义的 Array 中间元素能否被修改? 如果可以, 那 const 的意义是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-const\">[more]</a></li>\n<li>JavaScript 中不同类型以及不同环境下变量的内存都是何时释放? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md#q-mem\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/js-basic.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">模块</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E6%A8%A1%E5%9D%97%E6%9C%BA%E5%88%B6\"><code>[Basic]</code> 模块机制</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E7%83%AD%E6%9B%B4%E6%96%B0\"><code>[Basic]</code> 热更新</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#%E4%B8%8A%E4%B8%8B%E6%96%87\"><code>[Basic]</code> 上下文</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>a.js 和 b.js 两个文件互相 require 是否会死循环? 双方是否能导出变量? 如何从设计上避免这种问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-loop\">[more]</a></li>\n<li>如果 a.js require 了 b.js, 那么在 b 中定义全局变量 <code>t = 111</code> 能否在 a 中直接打印出来? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-global\">[more]</a></li>\n<li>如何在不重启 node 进程的情况下热更新一个 js/json 文件? 这个问题本身是否有问题? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md#q-hot\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/module.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">事件/异步</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#promise\"><code>[Basic]</code> Promise</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#events\"><code>[Doc]</code> Events (事件)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#timers\"><code>[Doc]</code> Timers (定时器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E9%98%BB%E5%A1%9E%E5%BC%82%E6%AD%A5\"><code>[Point]</code> 阻塞/异步</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#%E5%B9%B6%E8%A1%8C%E5%B9%B6%E5%8F%91\"><code>[Point]</code> 并行/并发</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Promise 中 .then 的第二参数与 .catch 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-1\">[more]</a></li>\n<li>Eventemitter 的 emit 是同步还是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-2\">[more]</a></li>\n<li>如何判断接口是否异步? 是否只要有回调函数就是异步? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-3\">[more]</a></li>\n<li>nextTick, setTimeout 以及 setImmediate 三者有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-4\">[more]</a></li>\n<li>如何实现一个 sleep 函数? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-5\">[more]</a></li>\n<li>如何实现一个异步的 reduce? (注:不是异步完了之后同步 reduce) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md#q-6\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/event-async.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">进程</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#process\"><code>[Doc]</code> Process (进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#child-process\"><code>[Doc]</code> Child Processes (子进程)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#cluster\"><code>[Doc]</code> Cluster (集群)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1\"><code>[Basic]</code> 进程间通信</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\"><code>[Basic]</code> 守护进程</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>进程的当前工作目录是什么? 有什么作用? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-cwd\">[more]</a></li>\n<li>child_process.fork 与 POSIX 的 fork 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-fork\">[more]</a></li>\n<li>父进程或子进程的死亡是否会影响对方? 什么是孤儿进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#q-child\">[more]</a></li>\n<li>cluster 是如何保证负载均衡的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#how-it-works\">[more]</a></li>\n<li>什么是守护进程? 如何实现守护进程? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/process.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">IO</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\"><code>[Doc]</code> Buffer</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#string-decoder\"><code>[Doc]</code> String Decoder (字符串解码)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#stream\"><code>[Doc]</code> Stream (流)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\"><code>[Doc]</code> Console (控制台)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\"><code>[Doc]</code> File System (文件系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\"><code>[Doc]</code> Readline</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#repl\"><code>[Doc]</code> REPL</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>Buffer 一般用于处理什么数据? 其长度能否动态变化? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#buffer\">[more]</a></li>\n<li>Stream 的 highWaterMark 与 drain 事件是什么? 二者之间的关系是? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E7%BC%93%E5%86%B2%E5%8C%BA\">[more]</a></li>\n<li>Stream 的 pipe 的作用是? 在 pipe 的过程中数据是引用传递还是拷贝传递? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#pipe\">[more]</a></li>\n<li>什么是文件描述符? 输入流/输出流/错误流是什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#file\">[more]</a></li>\n<li>console.log 是同步还是异步? 如何实现一个 console.log? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#console\">[more]</a></li>\n<li>如何同步的获取用户的输入?  <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#%E5%A6%82%E4%BD%95%E5%90%8C%E6%AD%A5%E7%9A%84%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E8%BE%93%E5%85%A5\">[more]</a></li>\n<li>Readline 是如何实现的? (有思路即可) <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md#readline\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/io.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">Network</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#net\"><code>[Doc]</code> Net (网络)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#udp\"><code>[Doc]</code> UDP/Datagram</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#http\"><code>[Doc]</code> HTTP</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#dns\"><code>[Doc]</code> DNS (域名服务器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#zlib\"><code>[Doc]</code> ZLIB (压缩)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#rpc\"><code>[Point]</code> RPC</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>cookie 与 session 的区别? 服务端如何清除 cookie? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cookie-session\">[more]</a></li>\n<li>HTTP 协议中的 POST 和 PUT 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-post-put\">[more]</a></li>\n<li>什么是跨域请求? 如何允许跨域? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-cors\">[more]</a></li>\n<li>TCP/UDP 的区别? TCP 粘包是怎么回事，如何处理? UDP 有粘包吗? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-tcp-udp\">[more]</a></li>\n<li><code>TIME_WAIT</code> 是什么情况? 出现过多的 <code>TIME_WAIT</code> 可能是什么原因? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#q-time-wait\">[more]</a></li>\n<li>ECONNRESET 是什么错误? 如何复现这个错误?</li>\n<li>socket hang up 是什么意思? 可能在什么情况下出现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md#socket-hang-up\">[more]</a></li>\n<li>hosts 文件是什么? 什么叫 DNS 本地解析?</li>\n<li>列举几个提高网络传输速度的办法?</li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/network.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">OS</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\"><code>[Doc]</code> TTY</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\"><code>[Doc]</code> OS (操作系统)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#path\"><code>[Doc]</code> Path</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0\"><code>[Doc]</code> 命令行参数</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\"><code>[Basic]</code> 负载</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#checklist\"><code>[Point]</code> CheckList</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>什么是 TTY? 如何判断是否处于 TTY 环境? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#tty\">[more]</a></li>\n<li>不同操作系统的换行符 (EOL) 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#os\">[more]</a></li>\n<li>服务器负载是什么概念? 如何查看负载? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#%E8%B4%9F%E8%BD%BD\">[more]</a></li>\n<li>ulimit 是用来干什么的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md#ulimit\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/os.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">错误处理/调试/优化</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#errors\"><code>[Doc]</code> Errors (异常)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\"><code>[Doc]</code> Domain (域)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#debugger\"><code>[Doc]</code> Debugger (调试器)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#c-c++-addon\"><code>[Doc]</code> C/C++ 插件</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#v8\"><code>[Doc]</code> V8</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\"><code>[Point]</code> 内存快照</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#cpu-profiling\"><code>[Point]</code> CPU profiling</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>怎么处理未预料的出错? 用 try/catch ，domains 还是其它什么? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#q-handle-error\">[more]</a></li>\n<li>什么是 <code>uncaughtException</code> 事件? 一般在什么情况下使用该事件? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#uncaughtexception\">[more]</a></li>\n<li>domain 的原理是? 为什么要弃用 domain? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#domain\">[more]</a></li>\n<li>什么是防御性编程? 与其相对的 let it crash 又是什么?</li>\n<li>为什么要在 cb 的第一参数传 error? 为什么有的 cb 第一个参数不是 error, 例如 http.createServer?</li>\n<li>为什么有些异常没法根据报错信息定位到代码调用? 如何准确的定位一个异常? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E9%94%99%E8%AF%AF%E6%A0%88%E4%B8%A2%E5%A4%B1\">[more]</a></li>\n<li>内存泄漏通常由哪些原因导致? 如何分析以及定位内存泄漏? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md#%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/error.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">测试</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95\"><code>[Basic]</code> 测试方法</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 单元测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 集成测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 基准测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95\"><code>[Basic]</code> 压力测试</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#assert\"><code>[Doc]</code> Assert (断言)</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>为什么要写测试? 写测试是否会拖累开发进度?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-why-write-test\">[more]</a></li>\n<li>单元测试的单元是指什么? 什么是覆盖率?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">[more]</a></li>\n<li>测试是如何保证业务逻辑中不会出现死循环的?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#q-death-loop\">[more]</a></li>\n<li>mock 是什么? 一般在什么情况下 mock?<a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md#mock\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/test.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">util</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#url\"><code>[Doc]</code> URL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#query-strings\"><code>[Doc]</code> Query Strings (查询字符串)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#util-1\"><code>[Doc]</code> Utilities (实用函数)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F\"><code>[Basic]</code> 正则表达式</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>HTTP 如何通过 GET 方法 (URL) 传递 let arr = [1,2,3,4] 给服务器? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#get-param\">[more]</a></li>\n<li>Node.js 中继承 (util.inherits) 的实现? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#utilinherits\">[more]</a></li>\n<li>如何递归获取某个文件夹下所有的文件名? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md#q-traversal\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/util.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">存储</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mysql\"><code>[Point]</code> Mysql</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#mongodb\"><code>[Point]</code> Mongodb</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\"><code>[Point]</code> Replication</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\"><code>[Point]</code> 数据一致性</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\"><code>[Point]</code> 缓存</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>备份数据库与 M/S, M/M 等部署方式的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#replication\">[more]</a></li>\n<li>索引有什么用，大致原理是什么? 设计索引有什么注意点? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%B4%A2%E5%BC%95\">[more]</a></li>\n<li>Monogdb 连接问题(超时/断开等)有可能是什么问题导致的? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#Mongodb\">[more]</a></li>\n<li>什么情况下数据会出现脏数据? 如何避免? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7\">[more]</a></li>\n<li>redis 与 memcached 的区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md#%E7%BC%93%E5%AD%98\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/storage.md\">阅读更多</a></p>\n<h2><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">安全</a></h2>\n<ul>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\"><code>[Doc]</code> Crypto (加密)</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\"><code>[Doc]</code> TLS/SSL</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\"><code>[Doc]</code> HTTPS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\"><code>[Point]</code> XSS</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\"><code>[Point]</code> CSRF</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\"><code>[Point]</code> 中间人攻击</a></li>\n<li><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#sqlnosql-%E6%B3%A8%E5%85%A5\"><code>[Point]</code> Sql/Nosql 注入</a></li>\n</ul>\n<h3>常见问题</h3>\n<ul>\n<li>加密是如何保证用户密码的安全性? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#crypto\">[more]</a></li>\n<li>TLS 与 SSL 有什么区别? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#tlsssl\">[more]</a></li>\n<li>HTTPS 能否被劫持? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#https\">[more]</a></li>\n<li>XSS 攻击是什么? 有什么危害? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>过滤 Html 标签能否防止 XSS? 请列举不能的情况? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#xss\">[more]</a></li>\n<li>CSRF 是什么? 如何防范? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#csrf\">[more]</a></li>\n<li>如何避免中间人攻击? <a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md#%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB\">[more]</a></li>\n</ul>\n<p><a href=\"https://github.com/ElemeFE/node-interview/blob/master/sections/zh-cn/security.md\">阅读更多</a></p>\n<h2>最后</h2>\n<p>目前 repo 处于施工现场的情况，如果发现问题欢迎在 <a href=\"https://github.com/ElemeFE/node-interview/issues\">issues</a> 中指出。如果有比较好的<code>问题/知识点/指正</code>，也欢迎提 PR。</p>\n<p>另外关于 <code>Js 基础</code> 是个比较大的话题，在本教程不会很细致深入的讨论，更多的是列出一些重要或者更服务端更相关的地方，所以如果你拿着《JavaScript 权威指南》给教程提 PR 可能不会采纳。本教程的重点更准确的说是服务端基础中 Node.js 程序员需要了解的部分。</p>\n</div>",
    "title": "饿了么大前端 Node.js 进阶教程",
    "last_reply_at": "2017-06-01T10:47:14.559Z",
    "good": true,
    "top": true,
    "reply_count": 149,
    "visit_count": 52429,
    "create_at": "2017-02-22T11:32:43.547Z",
    "author": {
      "loginname": "lellansin",
      "avatar_url": "https://avatars1.githubusercontent.com/u/2081487?v=3&s=120"
    }
  }, {
    "id": "592917b59e32cc84569a7458",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>",
    "title": "测试请发到客户端测试专区，违规影响用户的，直接封号",
    "last_reply_at": "2017-06-01T05:40:47.846Z",
    "good": false,
    "top": true,
    "reply_count": 21,
    "visit_count": 2110,
    "create_at": "2017-05-27T06:07:49.278Z",
    "author": {
      "loginname": "i5ting",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
    }
  }, {
    "id": "58d0fb3517f61387400b7e15",
    "author_id": "4f447c2f0a8abae26e01b27d",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/1ac00bee5abd7cc1d9a9435f861acba6.png\" alt=\"screenshot.png\"></p>\n<blockquote>\n<p>原文地址：<a href=\"https://zhuanlan.zhihu.com/p/25860846\">https://zhuanlan.zhihu.com/p/25860846</a></p>\n</blockquote>\n<hr>\n<p>时光如梭，转眼间 Egg.js 已经开源半年了，我们很荣幸地宣布，Egg.js 正式发布 1.0 版本。</p>\n<ul>\n<li>官网传送门：<a href=\"https://eggjs.org\">https://eggjs.org</a></li>\n<li>GitHub：<a href=\"https://github.com/eggjs/egg\">https://github.com/eggjs/egg</a></li>\n<li>Egg.js 英文文档：与 SwiftGG 翻译组强强联合，中译英的小伙伴招募中，如果你有兴趣，请试译 这篇文章 ，并注明你的 qq 号，发送给 SwiftGG 的同学邮箱(<a href=\"mailto:1030041592@qq.com\">1030041592@qq.com</a>)。期待你的加入！</li>\n</ul>\n<h2>特点</h2>\n<ul>\n<li><strong>『企业级的 Node.js Web 基础框架』</strong>，寓意 - 孕育新生。</li>\n<li>业界领先的 <strong>『微内核 + 插件机制』</strong>，专为团队架构师量身打造的 <strong>『框架定制』</strong> 能力。</li>\n<li>内建的安全机制与多进程管理模型。</li>\n<li>高可用，高质量，严格遵循 Semver 规则，测试覆盖率 100%（travis/appveyor)。</li>\n<li>同时支持 koa 1.x 和 2.x 生态，支持 ES 2017 Async Await。</li>\n<li>沉淀自阿里各行各业不同领域最佳实践的插件，涵盖了常见的业务开发场景，稳定支撑了 15 和 16 年天猫双11大促，顶级流量压力。</li>\n<li>渐进式，极具伸缩性，既适合个人小项目快速开发，也适合企业级的团队开发协作。</li>\n</ul>\n<blockquote>\n<p>更详细的特点，以及 Node.js 在阿里的定位，可以参见： <a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></p>\n</blockquote>\n<h2>里程碑</h2>\n<ul>\n<li>2013 年蚂蚁的 chair 框架，可视为 Egg.js 前身。</li>\n<li>2015 年 11 月，在苏千的召集下，阿里各 BU 的前端骨干齐聚黄龙，闭门共建一周。</li>\n<li>2016 年初，各 BU 的基础 Web 框架完成升级，在同一套规范的基础上进行差异化定制。</li>\n<li>2016 年中，成为阿里 Node.js 基建，广泛使用在绝大部分阿里的前端 Node.js 应用。</li>\n<li>2016 年 09 月，在 <a href=\"http://2016.jsconf.cn/\">JSConf China 2016</a> 上亮相并宣布开源。</li>\n<li>2017 年初，经过一周的<a href=\"https://cnodejs.org/topic/5870e9da04dcf9a706a745f0\">闭关直播写文档</a>，期待已久的 <a href=\"https://eggjs.org/\">官方文档</a> 诚意登场，足足近 30 篇。</li>\n<li>2017年 02 月，知乎问答：<a href=\"https://www.zhihu.com/question/50526101/answer/144952130\">如何评价阿里开源的企业级 Node.js 框架 egg？</a></li>\n<li>2017 年 02 月第 2 周，上了 <strong>GitHub Trending</strong> 周榜第三，Star 数增加 1k 多。</li>\n<li>2017 年 03 月 21 日，Egg.js 正式发布 1.0.0 。</li>\n</ul>\n<h2>成就</h2>\n<ul>\n<li>截止到今天，2250+ Star，50+ 插件，10+ 核心开发者，30+ 贡献者。</li>\n<li>GitHub Trending 周榜第三，并上了 Node Weekly 周刊。</li>\n<li>官网 UV 日均 300+ 。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/2a69766ae55cab517418e7b2f004d9b9.png\" alt=\"screenshot.png\"></p>\n<ul>\n<li>Node TSC Director - Rod Vagg 在 Twitter 上关注并转发。</li>\n</ul>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/42f3483f8c7b9a39678958816f477ae2.png\" alt=\"screenshot.png\"></p>\n<h2>感言</h2>\n<p><img src=\"http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/6461618ea8944a1fb5ada1db8aeb7de7.png\" alt=\"screenshot.png\"></p>\n<h2>规划</h2>\n<ul>\n<li>Egg.js 英文文档翻译，欢迎加入 <a href=\"http://swift.gg/\">SwiftGG 翻译组</a> 发起的 <a href=\"https://github.com/eggjs/egg/issues/363\">Egg 文档翻译项目</a>。</li>\n<li>继续完善文档，沉淀最佳实践，并帮助社区产出更多的插件和上层框架。</li>\n<li>Node.js 8 LTS 发布后，底层将无缝升级到 Koa<a href=\"/user/2\">@2</a> 。</li>\n</ul>\n</div>",
    "title": "Egg.js 1.0.0 正式发布 - 企业级 Node.js 框架",
    "last_reply_at": "2017-05-31T07:53:35.356Z",
    "good": false,
    "top": true,
    "reply_count": 144,
    "visit_count": 29355,
    "create_at": "2017-03-21T10:06:45.487Z",
    "author": {
      "loginname": "atian25",
      "avatar_url": "https://avatars.githubusercontent.com/u/227713?v=3&s=120"
    }
  }, {
    "id": "58eee565a92d341e48cfe7fc",
    "author_id": "54009f5ccd66f2eb37190485",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1>2017，我们来聊聊 Node.js</h1>\n<h2>版本帝？</h2>\n<p>Chrome浏览器已经蹦到57版本了，是名副其实的版本帝，作为兄弟的Node.js也一样，1.0之前等了6年，而从1.0到8.0，只用了2年时间，这世界到底怎么了？</p>\n<p>我们就数一下</p>\n<ul>\n<li>从v0.1到0.12用了6年</li>\n<li>2015-01-14发布了v1.0.0版本（io.js）</li>\n<li>2.x（io.js）</li>\n<li>3.x（io.js）</li>\n<li>2015年09月Node.js基金会已发布Node.js V4.0版 与io.js合并后的第一个版本</li>\n<li>2015年10月Node.jsv4.2.0将是首个lts长期支持版本</li>\n<li>2016年底发布到4.2.4 &amp;&amp; 5.4.0</li>\n<li>2016年3月20日v4.4.0 LTS（长期支持版本）和v5.9.0 Stable（稳定版本）</li>\n<li>2016 年底 v6.0 支持95%以上的es6特性 ， v7.0通过flag支持async函数，99%的es6特性</li>\n<li>2017年2月发布v7.6版本，可以不通过flag使用async函数</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fv8fvViUeOJpBlOWYzBo1txRUhdN\" alt=\"lts-schedule.png\"></p>\n<p>整体来说趋于稳定</p>\n<ul>\n<li>成立了Node.js基金会，能够让Node.js在未来有更好的开源社区支持</li>\n<li>发布了LTS版本，意味着api稳定</li>\n<li>快速发版本，很多人吐槽这个，其实换个角度看，这也是社区活跃的一个体现，但如果大家真的看CHANGELOG，其实都是小改进，而且是边边角角的改进，也就是说Node.js的core（核心）已经非常稳定了，可以大规模使用</li>\n</ul>\n<h2>已无性能优势？</h2>\n<p>Node.js在2009年横空出世，可以说是纯异步获得高性能的功劳。所有语言几乎没有能够和它相比的，比如Java、PHP、Ruby都被啪啪的打脸。但是山一程，水一程，福祸相依，因为性能太出众，导致很多语言、编程模型上有更多探索，比如go语言产生、php里的swolo和vm改进等，大家似乎都以不支持异步为耻辱。后来的故事大家都知道了，性能都提到非常高，c10问题已经没人再考虑，只是大家实现早晚而产生的性能差距而已。</p>\n<blockquote>\n<p>编程语言的性能趋于一样的极限，所以剩下的选择，只有喜好</p>\n</blockquote>\n<p>那么在这种情况下，Node.js还有优势么？</p>\n<ul>\n<li>实现成本：Node.js除了异步流程控制稍复杂外，其他的都非常简单，比如写法，你可以面向过程、面向对象、函数式，根据自己的解决选择就好了。不要因为它现在变化快，就觉得自己跟不上潮流。尤其是后端程序员转Node.js几乎是2周以内的成本，某些语言光熟悉语法习惯也不止2周吧？</li>\n<li>调优成本：Node.js即使不优化，它的性能也非常好，如果优化，也比其他语言更简单</li>\n<li>学习成本：是否必须用，如果是必须要用，那就少学一样是一样，人生有限，不能都花在写hello world上。我想问，大前端离得开js么？</li>\n</ul>\n<blockquote>\n<p>误读：Node.js已无性能优势，它现在最强大的是基于npm的生态</p>\n</blockquote>\n<p>上面是成本上的比较，其实大家把关注点都转移到基于npm的生态上，截止2017年2月，在npm上有超过45万个模块，秒杀无数。npm是所有的开源的包管理里最强大的，我们说更了不起的Node.js，其实npm居功甚伟，后面会有独立的章节进行阐述。</p>\n<p>来自<a href=\"http://www.modulecounts.com/\">www.modulecounts.com</a>的各个包管理模块梳理的比较</p>\n<p><img src=\"//dn-cnode.qbox.me/FjmazMxffKETUdl9-NVoSqLB-DyT\" alt=\"Screen Shot 2017-04-04 at 21.02.41.png\">\nnpm生态是Node的优势不假，可是说“Node.js没有性能优势”真的对么？这其实就是误读，Node.js的性能依然很好呀，而且它有npm极其强大的生态，可谓性能与生态双剑合璧，你说你死不死？</p>\n<h2>异步和回调地狱？</h2>\n<blockquote>\n<p>天生异步，败也异步，成也异步</p>\n</blockquote>\n<p>正因为异步导致了api设计方式只能采用error-first风格的回调，于是大家硬生生的把callback写成了callback hell。于是各种黑粉就冒出来，无非是一些浅尝辄止之辈。但也正因为回调地狱是最差实践，所以大家才不得不求变，于是thunk、promise等纷沓而至。虽然Promise/A+不完美，但对于解决回调地狱是足够的了。而且随着ES6等规范实现，引入generator、co等，让异步越来越近于同步。当async函数落地的时候，Node已经站在了同C#、Python一样的高度上，大家还有什么理由黑呢？</p>\n<p>本小节先科普一下异步流程里的各种概念，后面会有独立章节进行详细讲解</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>Node.js API天生就是这样的</td>\n<td></td>\n</tr>\n<tr>\n<td>thunk</td>\n<td>参数的求值策略</td>\n<td></td>\n</tr>\n<tr>\n<td>promise</td>\n<td>最开始是Promise/A+规范，随后成为ES6标准</td>\n<td></td>\n</tr>\n<tr>\n<td>generator</td>\n<td>ES6种的生成器，用于计算，但tj想用做流程控制</td>\n<td></td>\n</tr>\n<tr>\n<td>co</td>\n<td>generator用起来非常麻烦，故而tj写了co这个generator生成器，用法更简单</td>\n<td></td>\n</tr>\n<tr>\n<td>async函数</td>\n<td>原本计划进入es7规范，结果差一点，但好在v8实现了，所以node 7就可以使用，无须等es7规范落地</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>有时，将一件事儿做到极致，也许能有另一种天地</p>\n</blockquote>\n<h2>应用场景</h2>\n<p>MEAN是一个Javascript平台的现代Web开发框架总称，它是MongoDB + Express +AngularJS + NodeJS 四个框架的第一个字母组合。它与传统LAMP一样是一种全套开发工具的简称。在2014和2015年喜欢讲这个，并且还有MEAN.js等框架，但今天已经过时，Node.js有了更多的应用场景。</p>\n<p>《Node.js in action》一书里说，Node所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为Node自身在I/O上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。</p>\n<p>这话不假，但在今天来看，DIRT还是范围小了。其实DIRT本质上说的I/O处理的都算，但随着大前端的发展，Node.js已经不再只是I/O处理相关，而是更加的“Node”！</p>\n<p>这里给出Node.js的若干使用场景</p>\n<ul>\n<li>网站（如express/koa等）</li>\n<li>im即时聊天(<a href=\"http://socket.io\">socket.io</a>)</li>\n<li>api（移动端，pc，h5）</li>\n<li>HTTP Proxy（淘宝、Qunar、腾讯、百度都有）</li>\n<li>前端构建工具(grunt/gulp/bower/webpack/fis3…)</li>\n<li>写操作系统（NodeOS）</li>\n<li>跨平台打包工具（PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的cordova，即老的Phonegap，还有更加有名的一站式开发框架ionicframework）</li>\n<li>命令行工具（比如cordova、shell.js）</li>\n<li>反向代理（比如anyproxy，node-http-proxy）</li>\n<li>编辑器Atom、VSCode等</li>\n</ul>\n<p>可以说目前大家能够看到的、用到的软件都有Node.js身影，当下最流行的软件写法也大都是基于Node.js的，比如PC客户端<a href=\"https://github.com/luin/medis\">luin/medis</a>采用electron打包，写法采用React+Redux。我自己一直的实践的【Node全栈】，也正是基于这种趋势而形成的。在未来，Node.js的应用场景会更加的广泛。更多参见<a href=\"https://github.com/sindresorhus/awesome-nodejs\">sindresorhus/awesome-nodejs</a>。</p>\n<h3>Web框架</h3>\n<p>演进时间线大致如下：</p>\n<ul>\n<li>2010年tj写的Express</li>\n<li>2011年Derby.js开始开发，8月5日，WalmartLabs的一位成员Eran Hammer提交了Hapi的第一次commit。Hapi原本是Postmile的一部分，并且最开始是基于Express构建的。后来它发展成自己自己的框架，</li>\n<li>2012年1月21日，专注于rest api的restify发布1.0版本，同构的meteor开始投入开发，最像rails的sails也开始了开发</li>\n<li>2013年tj开始玩generator，编写co这个generator执行器，并开始了Koa。2013 年下半年李成银开始ThinkJS，参考ThinkPHP</li>\n<li>2014年，4月9日，express发布4.0，进入4.x时代持续到今天，MEAN.js开始随着MEAN架构的提出开始开发，意图大一统，另外total.js开始，最像PHP’s Laravel 或 Python’s Django 或 <a href=\"http://ASP.NET\">ASP.NET</a> MVC的框架</li>\n<li>2015年8月22日， 下一代Web框架Koa发布1.0，可以在node 0.12下面，通过co + generator实现同步逻辑，那时候co还是基于thunkfy的，2015.10.30 ThinkJS发布了Es2015+ 特性开发的v 2.0版本</li>\n<li>2016 年 09 月，蚂蚁金服的eggjs，在 JSConf China 2016 上亮相并宣布开源</li>\n<li>2017年2月，下一代Web框架Koa发布2.0</li>\n</ul>\n<p>我们可以根据框架的特性进行分类</p>\n<table>\n<thead>\n<tr>\n<th>框架名称</th>\n<th>特性</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Express</td>\n<td>简单、实用，路由中间件等五脏俱全</td>\n<td>最著名的Web框架</td>\n</tr>\n<tr>\n<td>Derby.js &amp;&amp; Meteor</td>\n<td>同构</td>\n<td>前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高</td>\n</tr>\n<tr>\n<td>Sails、Total</td>\n<td>面向其他语言，Ruby、PHP等</td>\n<td>借鉴业界优秀实现，也是Node.js成熟的一个标志</td>\n</tr>\n<tr>\n<td>MEAN.js</td>\n<td>面向架构</td>\n<td>类似于脚手架，又期望同构，结果只是蹭了热点</td>\n</tr>\n<tr>\n<td>Hapi和Restfy</td>\n<td>面向Api &amp;&amp; 微服务</td>\n<td>移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器</td>\n</tr>\n<tr>\n<td>ThinkJS</td>\n<td>面向新特性</td>\n<td>借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右</td>\n</tr>\n<tr>\n<td>Koa</td>\n<td>专注于异步流程改进</td>\n<td>下一代Web框架</td>\n</tr>\n</tbody>\n</table>\n<p>对于框架选型</p>\n<ul>\n<li>业务场景、特点，不必为了什么而什么，避免本末倒置</li>\n<li>自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定</li>\n<li>出现问题的时候，有人能Cover的住，Node.js虽然8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度</li>\n</ul>\n<blockquote>\n<p>个人学习求新，企业架构求稳，无非喜好与场景而已</p>\n</blockquote>\n<p>我猜大家能够想到的场景，大约如下</p>\n<ul>\n<li>前端工具，比如gulp、grunt、webpack等</li>\n<li>服务器，做类似于Java、PHP的事儿</li>\n</ul>\n<p>如果只是做这些，和Java、PHP等就没啥区别了。如果再冠上更了不起的Node.js，就有点名不符实了。所以这里我稍加整理，看看和大家想的是否一样</p>\n<h3>技术栈演进</h3>\n<p>自从ES 2015（俗称ES 6）在Node.js 落地之后，整个Node.js开发都发生了翻天覆地的变化。自从0.10开始，Node.js就逐渐的加入了ES 6特性，比如0.12就可以使用generator，才导致寻求异步流程控制的tj写出了co这个著名的模块，继而诞生了Koa框架。但是在4.0之前，一直都是要通过flag才能开启generator支持，故而Koa 1.0迟迟未发布，在Node 4.0发布才发布的Koa 1.0。</p>\n<blockquote>\n<p>2015年，成熟的传统，而2016年，变革开始</p>\n</blockquote>\n<p>核心变更：es语法支持</p>\n<ul>\n<li>使用Node.js 4.x或5.x里的es6特性，如果想玩更高级的，可以使用<a href>babel</a>编译支持es7特性，或者typescript</li>\n<li>合理使用<a href=\"https://github.com/feross/standard\">standard</a>  或者 xo 代码风格约定</li>\n<li>适当的引入ES 6语法，只要Node.js SDK支持的，都可以使用</li>\n<li>需要大家重视OO（面向对象）写法的学习和使用，虽然ES 6的OO机制不健全，但这是大方向，以后会一直增强。OO对于大型软件开发更好。这其实也是我看好typescript的原因。</li>\n</ul>\n<p>对比一下变革前后的技术栈选型，希望读者能够从中感受到其中的变化</p>\n<table>\n<thead>\n<tr>\n<th>分类</th>\n<th>2015年</th>\n<th>2016年</th>\n<th>选型原因</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web框架</td>\n<td>express 4.x</td>\n<td>koa 1.0 &amp;&amp; 2.0 （koa2.0刚发布不久，喜欢折腾的可以考虑）</td>\n<td>主要在流程控制上的便利，异步毕竟要时刻注意，心累</td>\n</tr>\n<tr>\n<td>数据库</td>\n<td>mongoose（mongodb）</td>\n<td>mongoose（mongodb）</td>\n<td>对mongodb和mysql支持都一样，不过是mongodb更简单，足以应付绝大部分场景</td>\n</tr>\n<tr>\n<td>异步流程控制</td>\n<td>bluebird（Promise/A+实现）</td>\n<td>bluebird（Promise/A+实现）1） Koa 1.0 使用co + generator 2） Koa 2.0 使用async函数</td>\n<td>流程控制演进路线，从promise到async函数，无论如何，promise都是基石，必要掌握的</td>\n</tr>\n<tr>\n<td>模板引擎（视图层）</td>\n<td>ejs &amp;&amp; jade</td>\n<td>jade &amp;&amp; nunjucks</td>\n<td>给出了2种，一种可读性好，另一种简洁高效，都是非常好的</td>\n</tr>\n<tr>\n<td>测试</td>\n<td>mocha</td>\n<td>ava</td>\n<td>mocha是Node.js里著名的测试框架，但对新特性的支持没有ava那么好，而ava基于babel安装也要大上好多</td>\n</tr>\n<tr>\n<td>调试</td>\n<td>node-inspector</td>\n<td>VSCode</td>\n<td>在Node 6和7出来之后，node-inspector支持的不是那么好，相反VSCode可视化，简单，文件多时也不卡，特别好用</td>\n</tr>\n</tbody>\n</table>\n<h3>预处理器</h3>\n<p>前端预处理可分3种</p>\n<ul>\n<li>模板引擎</li>\n<li>css预处理器</li>\n<li>js友好语言</li>\n</ul>\n<p>这些都离不开Node.js的支持，对于前端工程师来说，使用Node.js来实现这些是最方便不过的。</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>实现</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>模板引擎</td>\n<td>art\\mustache\\ejs\\hbs\\jade …</td>\n<td>上百种之多，自定义默认，编译成html，继而完成更多操作</td>\n</tr>\n<tr>\n<td>css预处理器</td>\n<td>less\\sass\\scss\\rework\\postcss</td>\n<td>自定义语法规则，编译成css</td>\n</tr>\n<tr>\n<td>js友好语言</td>\n<td>coffeescript、typescript</td>\n<td>自定义语法规则、编译成js</td>\n</tr>\n</tbody>\n</table>\n<h3>跨平台</h3>\n<p>跨平台指的是PC端、移动端、Web/H5</p>\n<table>\n<thead>\n<tr>\n<th>平台</th>\n<th>实现</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Web/H5</td>\n<td>纯前端</td>\n<td>不必解释</td>\n</tr>\n<tr>\n<td>PC客户端</td>\n<td>nw.js和electron</td>\n<td>尤其是atom和vscode编辑器最为著名，像钉钉PC端，微信客户端、微信小程序IDE等都是这样的，通过web技术来打包成PC客户端</td>\n</tr>\n<tr>\n<td>移动端</td>\n<td>cordova（旧称PhoneGap），基于cordova的ionicframework</td>\n<td>这种采用h5开发，打包成ipa或apk的应用，称为Hybrid开发（混搭），通过webview实现所谓的跨平台，应用的还是非常广泛的</td>\n</tr>\n</tbody>\n</table>\n<h3>构建工具</h3>\n<p>说起构建工具，大概会想到make、ant、rake、gradle等，其实Node.js里有更多实现</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>介绍</th>\n<th>点评</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>jake</td>\n<td>基于coffeescript的大概都熟悉这个，和make、rake类似</td>\n<td>经典传统</td>\n</tr>\n<tr>\n<td>grunt</td>\n<td>dsl风格的早期著名框架</td>\n<td>配置非常麻烦</td>\n</tr>\n<tr>\n<td>gulp</td>\n<td>流式构建，不会产生中间文件，利用Stream机制，处理大文件和内存有优势，配置简单，只有懂点js就能搞定</td>\n<td>grunt的替代品</td>\n</tr>\n<tr>\n<td>webpack + npm scripts</td>\n<td>说是构建工具有点过，但二者组合勉强算吧，loader和plugin机制还是非常强大的</td>\n<td>流行而已</td>\n</tr>\n</tbody>\n</table>\n<p>构建工具都不会特别复杂，所以Node.js世界里有非常多的实现，还有人写过node版本的make呢，玩的很嗨</p>\n<h3>HTTP Proxy</h3>\n<ul>\n<li>请求代理</li>\n<li>SSR &amp;&amp; PWA</li>\n<li>Api Proxy</li>\n</ul>\n<p>1）请求代理</p>\n<p>对于http请求复杂定制的时候，你是需要让Node.js来帮你的，比如为了兼容一个历史遗留需求，在访问某个CSS的时候必须提供HEADER才可以，如果放到静态server或cdn上是做不到的。</p>\n<p>2）SSR &amp;&amp; PWA</p>\n<p>SSR是服务器端渲染，PWA是渐进式Web应用，都是今年最火的技术。如果大家用过，一定对Node.js不陌生。比如React、Vuejs都是Node.js实现的ssr。至于pwa的service-worker也是Node.js实现的。那么为啥不用其他语言实现呢？不是其他语言不能实现，而是使用Node.js简单、方便、学习成本低，轻松获得高性能，如果用其他语言，我至少还得装环境</p>\n<p>3）Api Proxy</p>\n<p>产品需要应变，后端不好变，一变就要设计到数据库、存储等，可能引发事故。而在前端相对更容易，前端只负责组装服务，而非真正对数据库进行变动，所以只要服务api粒度合适，在前端来处理是更好的。</p>\n<p>Api的问题</p>\n<ul>\n<li>一个页面的Api非常多</li>\n<li>跨域，Api转发</li>\n<li>Api返回的数据对前端不友好，后端讨厌（应付）前端，几种api都懒得根据ui/ue去定制，能偷懒就偷懒</li>\n<li>需求决定Api，Api不一定给的及时</li>\n</ul>\n<p>所以，在前端渲染之余，加一层Api Proxy是非常必要的。淘宝早起曾公开过一张架构图，在今天看来，依然不过时</p>\n<p><img src=\"//dn-cnode.qbox.me/Fr8cGvus0i58atULAnoe-Cv4nu5m\" alt=\"taobao.jpg\"></p>\n<ul>\n<li>左侧半边，浏览器和Node.js Server通信可以有多种协议，HTML、RESTfull、BigPipe、Comet、Socket等，已经足够我们完成任何想做的事儿了</li>\n<li>右侧半边，是Node.js实现的WebServer，Node服务分了2个部分\n<ul>\n<li>常规的Http服务，即大块部分二</li>\n<li>ModelProxy指的是根据Server端的服务，组成并转化成自身的Model层。磨蹭用于为Http服务提供更好的接口</li>\n</ul>\n</li>\n</ul>\n<p>这里的Model Proxy其实就是我们所说的Api Proxy，这张图里只是说了结果，把聚合的服务转成模型，继而为HTTP服务提供Api。</p>\n<p>下面我们再深化一下Api Proxy的概念</p>\n<p><img src=\"//dn-cnode.qbox.me/FpAZo4aPQysJyciBvzUCU9uxb-vf\" alt=\"proxy.png\"></p>\n<p>这里的Node Proxy做了2件事儿，Api和渲染辅助。</p>\n<ul>\n<li>前端的异步ajax请求，可以直接访问Api</li>\n<li>如果是直接渲染或者bigpipe等协议的，需要在服务器端组装api，然后再返回给浏览器。</li>\n</ul>\n<p>所以Api后面还有一个服务组装，在微服务架构流行的今天，这种服务组装放到Node Proxy里的好处尤其明显。既可以提高前端开发效率，又可以让后端更加专注于服务开发。甚至如果前端团队足够大，可以在前端建一个Api小组，专门做服务集成的事儿。</p>\n<h3>Api服务</h3>\n<p>说完了Proxy，我们再看看利益问题。Node.js向后端延伸，必然会触动后端开发的利益。那么Proxy层的事儿，前后端矛盾的交界处，后端不想变，前端又求变，那么长此以往，Api接口会变得越来越恶心。后端是愿意把Api的事儿叫前端的，对后端来说，只要你不动我的数据库和服务就可以。</p>\n<p>但是Node.js能不能做这部分呢？答案是能的 ，这个是和Java、PHP类似的，一般是和数据库连接到一起，处理带有业务逻辑的。目前国内大部分都是以Java、PHP等为主，所以要想吃到这部分并不容易。</p>\n<ul>\n<li>小公司，创业公司，新孵化的项目更倾向于Node.js，简单，快速，高效</li>\n<li>微服务架构下的某些服务，使用Node.js开发，是比较合理的</li>\n</ul>\n<p>国内这部分一直没有做的很好，所以Node.js在大公司还没有很好的被应用，安全问题、生态问题、历史遗留问题等，还有很多人对Node.js的误解</p>\n<ul>\n<li>单线程很脆弱，这是事实，但单线程不等于不能多核并发，而且你还有集群呢</li>\n<li>运维，其实很简单，比其他语言之简单，日志采集、监控也非常简单</li>\n<li>模块稳定性，对于Mongodb、MySQL、Redis等还是相当不错，但其他的数据库支持可能没那么好。</li>\n<li>安全问题，</li>\n</ul>\n<p>这些对于提供Api服务来说已经足够了。</p>\n<h3>其他</h3>\n<table>\n<thead>\n<tr>\n<th>用途</th>\n<th>说明</th>\n<th>前景</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>爬虫</td>\n<td>抢了不少Python的份额，整体来说简单，实用</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>命令行工具</td>\n<td>写工具、提高效率，node+npm真是无出其右</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微服务与RPC</td>\n<td>Node做纯后端不好做，但在新项目和微服务架构下，必有一席之地</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>微信公众号开发</td>\n<td>已经火了2年多了，尤其是付费阅读领域，还会继续火下去，gitchat就是实用Node.js做的，而且还在招人</td>\n<td>看涨</td>\n</tr>\n<tr>\n<td>反向代理</td>\n<td>Node.js可以作为nginx这样的反向代理，虽然线上我们很少这样做，但它确确实实可以这样做。比如node-http-proxy和anyproxy等，其实使用Node.js做这种请求转发是非常简单的</td>\n<td>看涨</td>\n</tr>\n</tbody>\n</table>\n<h2>更好的写法</h2>\n<h3>Async函数与Promise</h3>\n<ul>\n<li>Async函数是趋势，Chrome 52. v8 5.1已经支持Async函数(<a href=\"https://github.com/nodejs/CTC/issues/7\">https://github.com/nodejs/CTC/issues/7</a>)了，Node.js 7.0+支持还会远么？</li>\n<li>Async和Generator函数里都支持promise，所以promise是必须会的。</li>\n<li>Generator和yield异常强大，不过不会成为主流，所以学会基本用法和promise就好了，没必要所有的都必须会。</li>\n<li>co作为Generator执行器是不错的，它更好的是当做Promise 包装器，通过Generator支持yieldable，最后返回Promise，是不是有点无耻？</li>\n</ul>\n<p>我整理了一张图，更直观一些。</p>\n<p><img src=\"//dn-cnode.qbox.me/FkcPwxdGHSCHFvA2nU0ub0zYNRt4\" alt=\"async-all.png\"></p>\n<ul>\n<li>红色代表Promise，是使用最多的，无论async还是generator都可用</li>\n<li>蓝色是Generator，过度货</li>\n<li>绿色是Async函数，趋势</li>\n</ul>\n<p><strong>结论</strong>：Promise是必须会的，那你为什么不顺势而为呢？</p>\n<p><strong>推荐</strong>：使用Async函数 + Promise组合，如下图所示。</p>\n<p><img src=\"//dn-cnode.qbox.me/FhVQF1FKB6sNkoFTc3gU-SVnkGtm\" alt=\"async-suggest.png\"></p>\n<p><strong>实践</strong></p>\n<p>合理的结合Promise和Async函数是可以非常高效的，但也要因场景而异</p>\n<ul>\n<li>Promise更容易做promisefyAll（比如使用bluebird）</li>\n<li>Async函数无法批量操作</li>\n</ul>\n<p>那么，在常见的Web应用里，我们总结的实践是，dao层使用Promise比较好，而service层，使用Async/Await更好。</p>\n<p>dao层使用Promise：</p>\n<ul>\n<li>crud</li>\n<li>单一模型的方法多</li>\n<li>库自身支持Promise</li>\n</ul>\n<p>这种用promisefyAll基本几行代码就够了，一般单一模型的操作，不会特别复杂，应变的需求基本不大。</p>\n<p>而service层一般是多个Model组合操作，多模型操作就可以拆分成多个小的操作，然后使用Await来组合，看起来会更加清晰，另外对需求应变也是非常容易的。</p>\n<h3>ES.next</h3>\n<blockquote>\n<p>Node.js + ES.next = ♥</p>\n</blockquote>\n<h3>Flow &amp;&amp; TypeScript</h3>\n<blockquote>\n<p>Type Systems Will Make You a Better JavaScript Developer</p>\n</blockquote>\n<h3>ES6模块</h3>\n<p>现在ES6自带了模块标准， 也是JS第一次支持module（之前的CommonJS、AMD、CMD都不算）， 但目前的所有Node.js版本都没有支持，目前只能用用Traceur、BabelJS， 或者TypeScript把ES6代码转化为兼容ES5版本的js代码，ES6模块新特性非常吸引人，下面简要说明。</p>\n<p>ES6 模块的目标是创建一个同时兼容CommonJS和AMD的格式，语法更加紧凑，通过编译时加载，使得编译时就能确定模块的依赖关系，效率要比 CommonJS 模块的加载方式高。而对于异步加载和配置模块加载方面，则借鉴AMD规范，其效率、灵活程度都远远好于CommonJS写法。</p>\n<ul>\n<li>语法更紧凑</li>\n<li>结构更适于静态编译（比如静态类型检查，优化等）</li>\n<li>对于循环引用支持更好</li>\n</ul>\n<p>ES6 模块标准只有2部分，它的用法更简单，你根本不需要关注实现细节:</p>\n<ul>\n<li>声明式语法：模块导入import、导出export，没有require了</li>\n<li>程式化加载API：可以配置模块是如何加载，以及按需加载。</li>\n</ul>\n<h3>多模块管理器：Lerna</h3>\n<blockquote>\n<p>A tool for managing JavaScript projects with multiple packages.</p>\n</blockquote>\n<p><a href=\"https://lernajs.io/\">https://lernajs.io/</a></p>\n<p>在设计框架的时候，经常做的事儿是进行模块拆分，继而提供插件或集成机制，这样是非常好的做法。但问题也随之而来，当你的模块模块非常多时，你该如何管理你的模块呢？</p>\n<ul>\n<li>法1：每个模块都建立独立的仓库</li>\n<li>法2：所有模块都放到1个仓库里</li>\n</ul>\n<p>法1虽然看起来干净，但模块多时，依赖安装，不同版本兼容等，会导致模块间依赖混乱，出现非常多的重复依赖，极其容易造成版本问题。这时法2就显得更加有效，对于测试，代码管理，发布等，都可以做到更好的支持。</p>\n<p>Lerna就是基于这种初衷而产生的专门用于管理Node.js多模块的工具，当然，前提是你有很多模块需要管理。</p>\n<p>你可以通过npm全局模块来安装Lerna，官方推荐直接使用Lerna 2.x版本</p>\n<h3>更好的NPM替代品：Yarn</h3>\n<p>Yarn是开源JavaScript包管理器，由于npm在扩展内部使用时遇到了大小、性能和安全等问题，Facebook携手来自Exponent、Google和Tilde的工程师，在大型JavaScript框架上打造和测试了Yarn，以便其尽可能适用于多人开发。Yarn承诺比各大流行npm包的安装更可靠，且速度更快。根据你所选的工作包的不同，Yarn可以将安装时间从数分钟减少至几秒钟。Yarn还兼容npm注册表，但包安装方法有所区别。其使用了lockfiles和一个决定性安装算法，能够为参与一个项目的所有用户维持相同的节点模块（node_modules）目录结构，有助于减少难以追踪的bug和在多台机器上复制。</p>\n<p>Yarn还致力于让安装更快速可靠，支持缓存下载的每一个包和并行操作，允许在没有互联网连接的情况下安装（如果此前有安装过的话）。此外，Yarn承诺同时兼容npm和Bower工作流，让你限制安装模块的授权许可。</p>\n<p>2016年10月份, Yarn在横空出世不到一周的时间里，github上的star数已经过万，可以看出大厂及社区的活跃度，以及解决问题的诚意，大概无出其右了！</p>\n<p>替换的原因</p>\n<ul>\n<li>在Facebook的大规模 npm 都工作的不太好</li>\n<li>npm拖慢了公司的ci工作流</li>\n<li>对一个检查所有的模块也是相当低效的</li>\n<li>npm被设计为是不确定性的，而Facebook工程师需要为他们的DevOps工作流提供一直和可依赖的系统</li>\n</ul>\n<p>与hack npm限制的做法相反，Facebook编写了Yarn</p>\n<ul>\n<li>Yarn 的本地缓存文件做的更好</li>\n<li>Yarn 可以并行它的一些操作，这加速了对新模块的安装处理</li>\n<li>Yarn 使用lockfiles，并用确定的算法来创建一个所有跨机器上都一样的文件</li>\n<li>出于安全考虑，在安装进程里，Yarn 不允许编写包的开发者去执行其他代码</li>\n</ul>\n<blockquote>\n<p>Yarn, which promises to even give developers that don’t work at Facebook’s scale a major performance boost, still uses the npm registry and is essentially a drop-in replacement for the npm client.</p>\n</blockquote>\n<p>很多人说和ruby的gem机制类似，都生成lockfile。确实是一个很不错的改进，在速度上有很大改进，配置cnpm等国内源来用，还是相当爽的。</p>\n<h3>友好语言</h3>\n<ul>\n<li>过气的Coffeescript，不多说</li>\n<li><a href=\"https://babeljs.io/\">Babel</a> - also an ES6 to ES5 transpiler that’s growing in popularity possibly because it also supports React’s JSX syntax. As of today it supports the most ES6 features at a somewhat respectable 73%.</li>\n<li><a href=\"http://www.typescriptlang.org/\">TypeScript</a> - a typed superset of JavaScript that not only compiles ES6 to ES5 (or even ES3) but also supports optional variable typing. TypeScript only supports 53% of ES6 features.</li>\n</ul>\n<h2>总结</h2>\n<blockquote>\n<p>坦诚的力量是无穷的</p>\n</blockquote>\n<p>Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。</p>\n<p>直面问题才能有更好的解决方式，Node.js你值得拥有！</p>\n</div>",
    "title": "2017，我们来聊聊 Node.js",
    "last_reply_at": "2017-05-27T06:03:10.897Z",
    "good": true,
    "top": true,
    "reply_count": 75,
    "visit_count": 20705,
    "create_at": "2017-04-13T02:41:41.818Z",
    "author": {
      "loginname": "i5ting",
      "avatar_url": "https://avatars0.githubusercontent.com/u/3118295?v=3&s=120"
    }
  }, {
    "id": "592f6410d371b6372a8aff7a",
    "author_id": "57fef4a9fdf3bd3d6511858f",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>我做的项目其他后台的功能差不多了，关于用户系统这一块以前没接触过。需要有登录之后项目没荒废还想做微信的认证之类的。\n我用的框架是koa2，有没有开源的框架（最好简单文档清楚点，怕看不懂），或者哪位大神在github上有这样的项目能参考下</p>\n</div>",
    "title": "请教下用户系统怎么做",
    "last_reply_at": "2017-06-02T01:11:14.943Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 201,
    "create_at": "2017-06-01T00:47:12.103Z",
    "author": {
      "loginname": "IEfucker",
      "avatar_url": "https://avatars3.githubusercontent.com/u/3446876?v=3&s=120"
    }
  }, {
    "id": "592fc4f6e018d6750dbfa0ff",
    "author_id": "5881b3b95d4612c33919e8ce",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FlQ__I3XGVpiL1CUAYGcVm2XG_dT\" alt=\"1496302536(1).jpg\"></p>\n<p>如图所示，post发送数据，请求出现400错误，麻烦大佬们看下。。。</p>\n</div>",
    "title": "练手客户端项目  主题发布功能测试失败",
    "last_reply_at": "2017-06-02T01:11:03.503Z",
    "good": false,
    "top": false,
    "reply_count": 2,
    "visit_count": 109,
    "create_at": "2017-06-01T07:40:38.578Z",
    "author": {
      "loginname": "TonyYu2015",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10993124?v=3&s=120"
    }
  }, {
    "id": "5930baafe018d6750dbfa149",
    "author_id": "5881b3b95d4612c33919e8ce",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>主题发布功能测试主题发布功能测试主题发布功能测试</p>\n</div>",
    "title": "testtesttesttest",
    "last_reply_at": "2017-06-02T01:09:03.064Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 8,
    "create_at": "2017-06-02T01:09:03.064Z",
    "author": {
      "loginname": "TonyYu2015",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10993124?v=3&s=120"
    }
  }, {
    "id": "5930ba592cace39d0de58b30",
    "author_id": "5881b3b95d4612c33919e8ce",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>主题发布功能测试主题发布功能测试主题发布功能测试</p>\n</div>",
    "title": "testtesttesttest",
    "last_reply_at": "2017-06-02T01:07:37.835Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 8,
    "create_at": "2017-06-02T01:07:37.835Z",
    "author": {
      "loginname": "TonyYu2015",
      "avatar_url": "https://avatars1.githubusercontent.com/u/10993124?v=3&s=120"
    }
  }, {
    "id": "5930b944e018d6750dbfa147",
    "author_id": "57e241557e77820e3acfe0e7",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>Ignored attempt to cancel a touchend event with cancelable=false, for example because scrolling is in progress and cannot be interrupted.</p>\n</div>",
    "title": "浏览器给出了一个警告，怎么回避这个警告",
    "last_reply_at": "2017-06-02T01:03:00.186Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 15,
    "create_at": "2017-06-02T01:03:00.186Z",
    "author": {
      "loginname": "yangkuo1993",
      "avatar_url": "https://avatars3.githubusercontent.com/u/16241614?v=3&s=120"
    }
  }, {
    "id": "592f57ca855efbac2cf7a532",
    "author_id": "56743b1ac096b56a0c1b4308",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>我参照 Cnode 源码写的项目，但不知道哪里出问题了，根据 userid 查询的用户信息不能保存到对象里。</p>\n<pre class=\"prettyprint\"><code>const ep = new eventproxy();\n  ep.fail(next);\n\n  EveryDay.getRankByTodayDate(TodayDate, ep.done(&#x27;ranks&#x27;));\n\n  ep.all(&#x27;ranks&#x27;, function(ranks){\n    ranks.forEach(function(rank){\n      User.getUserById(rank.userId, ep.done(function(user){\n        rank.nickName = user.nickName; &#x2F;&#x2F;这里不生效\n        console.log(rank,rank.nickName); rank.nickName 有值，但是打印出的rank没有nickName 属性\n        ep.emit(&#x27;user&#x27;);\n      }))\n    });\n</code></pre><pre class=\"prettyprint\"><code>rank.nickName = user.nickName;\n</code></pre><p>为什么直接这样赋值不生效那？这里应该怎么把查询到的用户昵称保存到数据对象里？</p>\n<p>我看本站的源码就是直接赋值的，我遗漏了什么吗？麻烦大家，指点一下。</p>\n<p>我在网上找到了这种解决方法，但是还是不懂本站的源码怎么处理的：</p>\n<pre class=\"prettyprint\"><code> EveryDay.find({TodayDate}).lean()\n    .exec((err, ranks) =&gt; {\n\t...\n\t}\n\t)\n</code></pre></div>",
    "title": "mongoose 通过UserId 获取用户信息，不能保存到对象",
    "last_reply_at": "2017-06-02T01:02:31.076Z",
    "good": false,
    "top": false,
    "reply_count": 10,
    "visit_count": 199,
    "create_at": "2017-05-31T23:54:50.747Z",
    "author": {
      "loginname": "Youthink",
      "avatar_url": "https://avatars0.githubusercontent.com/u/9588284?v=3&s=120"
    }
  }, {
    "id": "592fdc2f03dba3510d8a62a0",
    "author_id": "58edae8949056f03483477e8",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>现在项目遇到了一点问题，表现是命令行有打印，能收到请求，但是不吐数据，\n经坛友指点，现在怀疑是资源没释放导致的，所以想加一个超时处理，\n然后看了express的教程，貌似可以用connect-timeout中间件解决\n但是这个中间件在项目里始终要报can’t set headers after they are sent.\n目前也没什么好的解决办法，各位有主意吗？</p>\n</div>",
    "title": "express响应超时应该怎么做？",
    "last_reply_at": "2017-06-02T00:43:48.370Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 79,
    "create_at": "2017-06-01T09:19:43.692Z",
    "author": {
      "loginname": "lzszone",
      "avatar_url": "https://avatars3.githubusercontent.com/u/16443301?v=3&s=120"
    }
  }, {
    "id": "5930430f03dba3510d8a62c6",
    "author_id": "57b3bfd4d6124db37b1d1333",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><ol>\n<li>\n<p>在使用axios发送请求时，服务器端设置 res.header(“Access-Control-Allow-Origin”, “*”);可以正确得到结果</p>\n</li>\n<li>\n<p>当服务器端不设置允许跨域时，使用jsonp方式发送就不行了，提示错误如下</p>\n<pre class=\"prettyprint\"><code>XMLHttpRequest cannot load http:&#x2F;&#x2F;localhost:3000&#x2F;axios?cb=cb. No &#x27;Access-Control-Allow-Origin&#x27; header is present on the requested resource. Origin &#x27;null&#x27; is therefore not allowed access.\n</code></pre></li>\n</ol>\n<p>那个小伙伴在Vue中使用axios发送跨域请求，请赐教！</p>\n</div>",
    "title": "Vue中如何使用axios发送jsonp跨域验证",
    "last_reply_at": "2017-06-02T00:42:36.971Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 65,
    "create_at": "2017-06-01T16:38:39.744Z",
    "author": {
      "loginname": "justbecoder",
      "avatar_url": "https://avatars1.githubusercontent.com/u/21071133?v=3&s=120"
    }
  }, {
    "id": "54052722e84941a5713f3e72",
    "author_id": "5403e24ecd66f2eb37bc4587",
    "content": "<div class=\"markdown-text\"><p><strong>错误如下：</strong>\nReferenceError: /Users/victor/mymicroblog/views/layout.ejs:4\n2| &lt;html&gt;\n3|   &lt;head&gt;</p>\n<blockquote>\n<blockquote>\n<p>4|     &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;\n5|     &lt;link rel=‘stylesheet’ href=’/stylesheets/bootstrap.css’ /&gt;\n6|     &lt;style type=“text/css”&gt;\n7|       body {\ntitle is not defined</p>\n</blockquote>\n</blockquote>\n<p><strong>访问页面locathost:3000/显示内容如下：</strong>\nReferenceError: /Users/victor/mymicroblog/views/layout.ejs:4 2| &lt;html&gt; 3| &lt;head&gt; &gt;&gt; 4| &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; 5| &lt;link rel=‘stylesheet’ href=’/stylesheets/bootstrap.css’ /&gt; 6| &lt;style type=“text/css”&gt; 7| body { title is not defined at eval (eval at &lt;anonymous&gt; (/Users/victor/mymicroblog/node_modules/ejs/lib/ejs.js:237:14), &lt;anonymous&gt;:29:89) at eval (eval at &lt;anonymous&gt; (/Users/victor/mymicroblog/node_modules/ejs/lib/ejs.js:237:14), &lt;anonymous&gt;:29:2010) at /Users/victor/mymicroblog/node_modules/ejs/lib/ejs.js:250:15 at Object.exports.render (/Users/victor/mymicroblog/node_modules/ejs/lib/ejs.js:288:13) at View.exports.renderFile [as engine] (/Users/victor/mymicroblog/node_modules/ejs/lib/ejs.js:318:20) at View.render (/Users/victor/mymicroblog/node_modules/express/lib/view.js:76:8) at Function.app.render (/Users/victor/mymicroblog/node_modules/express/lib/application.js:503:10) at ServerResponse.res.render [as partial] (/Users/victor/mymicroblog/node_modules/express/lib/response.js:802:7) at /Users/victor/mymicroblog/node_modules/express-partials/index.js:75:13 at View.exports.renderFile [as engine] (/Users/victor/mymicroblog/node_modules/ejs/lib/ejs.js:318:3)</p>\n<p><strong>我的layout.ejs相关代码片段如下：</strong>\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;\n&lt;link rel=‘stylesheet’ href=’/stylesheets/bootstrap.css’ /&gt;\n&lt;style type=“text/css”&gt;\nbody {\npadding-top: 60px;\npadding-bottom: 40px;}\n&lt;/style&gt;\n…</p>\n<p><strong>我的routes/index.js相关代码片段如下：</strong>\nrouter.get(’/’, function(req, res) {\nres.render(‘index’, { title: ‘首页’ });\n});</p>\n</div>",
    "title": "Node.js 报错 \"title is not defined\"",
    "last_reply_at": "2017-06-01T20:40:01.102Z",
    "good": false,
    "top": false,
    "reply_count": 5,
    "visit_count": 7958,
    "create_at": "2014-09-02T02:10:42.770Z",
    "author": {
      "loginname": "ChoCheckTsui",
      "avatar_url": "//gravatar.com/avatar/ee4e670115ae30dca9310fd2c0b20db0?size=48"
    }
  }, {
    "id": "56442b4723e4803b17d852cc",
    "author_id": "5627b36b1af271c54823a7e0",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>function GetHtml(url){\n\t//获取编码是gbk的页面源码\n\tnodegrass.get(_host+url,function(data,status,headers){\nvar index=data.indexOf(“中文”); //结果是-1\n},‘gbk’).on(‘error’, function(e) {\nconsole.log(&quot;Got error: &quot; + e.message);\n});\n}\n求教为嘛 我输出的是 中文 但是 我用indexOf 去找 结果是-1</p>\n<p><img src=\"//dn-cnode.qbox.me/Fmyhk2JzWbwP17w7aE6za8-7Ym4u\" alt=\"QQ截图20151112164433.png\"></p>\n</div>",
    "title": "node.js gbk编码的字符串 为嘛不能拼接中文  或者 indexOf(\"中文“) 查找",
    "last_reply_at": "2017-06-01T17:42:10.206Z",
    "good": false,
    "top": false,
    "reply_count": 8,
    "visit_count": 1486,
    "create_at": "2015-11-12T06:01:43.712Z",
    "author": {
      "loginname": "XuCe",
      "avatar_url": "https://avatars.githubusercontent.com/u/4842592?v=3&s=120"
    }
  }, {
    "id": "593040c8e018d6750dbfa13c",
    "author_id": "5897d4725dfbcdfa083b3f9a",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>端午节结束了。虽然接下来的四个月都没有节假日，但笔者一点都不烦恼。因为 Node.js 8 在端午后第一个工作日就正式发布，这足以让我与 Node.js 的激情燃烧一个夏天！本文挑选了笔者认为 Node.js 8 最令人兴奋的四大新功能，与大家分享。</p>\n<h3>async/await 与 util.promisify</h3>\n<p>Node.js 一直以来的关键设计就是把用户关在一个“异步编程的监狱”里，以换取非阻塞 I/O 的高性能，让用户轻易开发出高度可扩展的网络服务器。这从 Node.js 的 API 设计上就可见一斑，很多API——如 fs.open(path, flags[, mode], callback)——要求用户必须把该操作执行成功后的逻辑放在最后参数里，作为函数传递进去；而 fs.open 本身是立即返回的，用户不能把依赖于 fs.open 结果的逻辑与 fs.open 本身线性地串联起来。</p>\n<p>在这座“异步编程的监狱”里，不掌握异步编程就寸步难行。而我们习惯性地使用线性思维去思考业务问题，却在实现的时候，被迫把业务逻辑被切成很多小片段去书写，就是一件很痛苦的事情了。为了减轻异步编程的痛苦，几年间我们见证了数个解决方案的出现：从深度嵌套的回调金字塔，到带有长长的 then() 链条的 Promise 设计模式，再到 Generator 函数，到如今 Node.js 8 的 async/await 操作符。笔者认为，所有这些解决方案中，async/await 操作符是最接近命令式编程风格的，使用起来最为自然的。</p>\n</div>",
    "title": "端午节后福利：Node.js 8",
    "last_reply_at": "2017-06-01T16:28:56.578Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 45,
    "create_at": "2017-06-01T16:28:56.578Z",
    "author": {
      "loginname": "sufangyu",
      "avatar_url": "https://avatars2.githubusercontent.com/u/1852629?v=3&s=120"
    }
  }, {
    "id": "59294bff9e32cc84569a746a",
    "author_id": "590d7e623504ce1c2ac45912",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h2>一、写在前面的话</h2>\n<blockquote>\n<p>  Node.js是一个开放源代码、跨平台的JavaScript语言运行环境，采用Google开发的V8运行代码,使用事件驱动、非阻塞和异步输入输出模型等技术来提高性能，可优化应用程序的传输量和规模。这些技术通常用于数据密集的事实应用程序。——<a href=\"https://zh.wikipedia.org/wiki/Node.js\">来自维基百科</a></p>\n</blockquote>\n<p>  最近花了差不多近一个月的时间去学习Node.js，由于它的代码语言是 Javascript ，因此对于语法上就没有过多的去研究，毕竟做过Web开发的程序员，很少有不会Javascript的。而写这篇文章，也只是为了\n<img src=\"http://img.blog.csdn.net/20170526153545011?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"“记录装逼的过程”\"></p>\n<p>如有不正确的地方，希望大家指正。</p>\n<h2>二、准备工作</h2>\n<p>  在正式开始码代码之前，我们需要准备以下东西：</p>\n<ol>\n<li>搭建 Node 环境。Node的安装过程太过简单，网上也有太多的教程，大家可以自行百度；</li>\n<li>申请微信公众号，同样这里也不做介绍，大家自行百度。</li>\n<li>服务器和域名。</li>\n<li>打开 Node.js中文网文档</li>\n<li>打开 微信开发者文档</li>\n</ol>\n<h2>三、接入微信公众平台</h2>\n<h3>1.创建Node.js 项目</h3>\n<p>  首先我们在电脑的任意磁盘上创建文件夹，命名随意，我这命名为 wechat;\n  随后在文件夹中创建两个文件,一个是config.json，另一个为app.js。如下图所示：\n<img src=\"http://img.blog.csdn.net/20170526162830506?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Node.js项目\">\nPS:这里我的 IDE 是 VSCode，各位可随意使用自己喜欢的 IDE。</p>\n<p>  为了后续功能的扩展，我加入了Express框架，具体操作如下：</p>\n<ol>\n<li>电脑打开运行界面，快捷键为：win+R，输入cmd后回车，进入dos界面，输入命令</li>\n</ol>\n<pre class=\"prettyprint\"><code> npm install -g express\n</code></pre><p>进行全局安装；由于 Express 自 4.x 版本中将命令工具分离出来，因此还需要输入下一个命令</p>\n<pre class=\"prettyprint\"><code>npm install -g express-generator@4\n</code></pre><p>安装成功后，在dos界面中输入以下 命令</p>\n<pre class=\"prettyprint\"><code>express -h\n</code></pre><p>结果如下图所示：\n<img src=\"http://img.blog.csdn.net/20170526165449343?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"express 安装成功\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170526170048694?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"震惊\">什么？你的运行结果提示：express不是内部或外部命令。那你必须要检查一下安装 node.js 的时候有没有添加环境变量。点击<a href=\"http://jingyan.baidu.com/article/1876c8529c79e2890b1376dd.html?st=2&amp;net_type=&amp;bd_page_type=1&amp;os=0&amp;rst=&amp;word=WWWDHZJS.ORG\">解决express不是内部或外部命令问题</a></p>\n<h3>2.微信文档步骤</h3>\n<p>  如果在没有考虑清楚之前，就开始码代码的话，这样做是非常危险的。我们先打开微信文档，点击 开始开发 中的 接入指南，如图：\n<img src=\"http://img.blog.csdn.net/20170526173347334?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"接入指南\"></p>\n<p>跳过第一步，直接看第二步，如图：\n<img src=\"http://img.blog.csdn.net/20170526173618682?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"验证消息来自微信服务器\"></p>\n<p>正如帮助文档所说的那样，我们总结以四个步骤：</p>\n<ol>\n<li>获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr</li>\n<li>将token、timestamp、nonce三个参数进行字典序排序</li>\n<li>将三个参数字符串拼接成一个字符串进行sha1加密</li>\n<li>开发者获得加密后的字符串可与signature对比，标识该请求来源于微信</li>\n</ol>\n<h3>3.接入功能的实现</h3>\n<p>   整理好思路后我们就按照上一节的步骤去实现。首先我们在打开 config.json 文件,输入以下内容：</p>\n<pre class=\"prettyprint language- json\"><code>{\n    &quot;token&quot;:&quot;wechat&quot;\n}\n</code></pre><p>   config.json 文件是我们程序的配置文件，在后面的文章中，我们会将程序名称、微信定义的参数名称、请求地址等配置内容存放在该文件中。\n   打开 app.js 文件，该文件属于我们程序的入口，在文件启动及以后路由配置都是再次实现的，首先我们导入重要的模块：</p>\n<pre class=\"prettyprint language-javascript\"><code>const express = require(&#x27;express&#x27;), &#x2F;&#x2F;express 框架 \n       crypto = require(&#x27;crypto&#x27;),  &#x2F;&#x2F;引入加密模块\n       config = require(&#x27;.&#x2F;config&#x27;);&#x2F;&#x2F;引入配置文件\n</code></pre><p>上面的代码不难理解，require  就是导入模块的意思。这里主要针对我们自定义的config.json文件讲解一下：\n “./” 表示与 app.js 在同一及目录下，为什么要这么写呢？原因很简单就是在我们通过 npm 命令安装模块时，如果我们指定了全局安装，也就是 -g，安装后的文件则会保存在我们 node.js 安装路径下的 node_modules 文件夹中；同理，我们不指定全局安装，安装后的文件则会保存在我们安装命令输入时所在的文件夹根目录下的  node_modules  文件夹中，此时如果没有该文件，系统会自动创建。</p>\n<p> 这里我们都是使用  require 去导入模块的，node.js 怎么分辨系统模块和我们自定义的模块呢，聪明的你一定想到了，没错就是 “./” 这个，如果你不想用它的话，你也可以把自定义的模块文件移到  node_modules 文件夹中。</p>\n<p>  require 是通过模块名称去导入模块文件的，因此在引入的时候不需要写入文件的后缀名。如果两个文件重名，但后缀名不同， require  会按照 Node.js 的加载优先级顺序进行导入，即 js文件 &gt; json文件 &gt; node文件。</p>\n<p><img src=\"http://img.blog.csdn.net/20170526183406152?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"原来如此\">\n 实际上就是这么简单，我们也就不再纠结这个问题，继续下面的工作。</p>\n<p>   实例 express 以及 创建服务器</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;实例 express\nvar app = express();\n&#x2F;&#x2F;用于处理所有进入 3000 端口 get 的连接请求\napp.get(&#x27;&#x2F;&#x27;,function(req,res){\n\t&#x2F;&#x2F;对请求连接返回内容\n    res.send(&quot;Hello Node.js&quot;);\n});\n&#x2F;&#x2F;监听3000端口\napp.listen(3000);\n</code></pre><p>  上面的代码通过注释，我们就能明白其意思，这里我就不再做细致的讲解。再次进入 dos 界面，通过命令进入我们项目的文件的根目录下，如图：\n<img src=\"http://img.blog.csdn.net/20170527094523235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"进入项目根目录下\">\n输入命令，启动我们的Node.js项目</p>\n<pre class=\"prettyprint\"><code>node app.js\n</code></pre><p>启动成功后，我们打开浏览器输入地址：<a href=\"http://localhost:3000\">http://localhost:3000</a> 访问我们的node.js项目，如图\n<img src=\"http://img.blog.csdn.net/20170527095856727?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"启动node.js项目\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170527100348487?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"范文结果\"></p>\n<blockquote>\n<p>小技巧 ：\n  在每次更改完 node.js 项目后，我们都需要先将 node.js停止（快捷键: Ctrl+C），然后再通过命令再次运行，这样特别麻烦。这里我推荐使用 supervisor  工具，npm 安装命令为：npm install -g supervisor。这样我们启动 node.js 项目命令改为 supervisor app.js，更改项目后只需要保存，刷新浏览器页面就可以得到更改后的结果了。</p>\n</blockquote>\n<p>  完成上面的工作后，我们就可以正式开始写接入微信公众平台的主要代码，废话不多说直接贴代码\n<img src=\"http://img.blog.csdn.net/20170527102640581?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"后退！我要开始装逼了\"></p>\n<pre class=\"prettyprint language-javascript\"><code>const express = require(&#x27;express&#x27;), &#x2F;&#x2F;express 框架 \n       crypto =  require(&#x27;crypto&#x27;), &#x2F;&#x2F;引入加密模块\n       config = require(&#x27;.&#x2F;config&#x27;);&#x2F;&#x2F;引入配置文件\n\nvar app = express();&#x2F;&#x2F;实例express框架\n\n&#x2F;&#x2F;用于处理所有进入 3000 端口 get 的连接请求\napp.get(&#x27;&#x2F;&#x27;,function(req,res){\n    &#x2F;&#x2F;1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\n    var signature = req.query.signature,&#x2F;&#x2F;微信加密签名\n        timestamp = req.query.timestamp,&#x2F;&#x2F;时间戳\n            nonce = req.query.nonce,&#x2F;&#x2F;随机数\n          echostr = req.query.echostr;&#x2F;&#x2F;随机字符串\n\n    &#x2F;&#x2F;2.将token、timestamp、nonce三个参数进行字典序排序\n    var array = [config.token,timestamp,nonce];\n    array.sort();\n\n    &#x2F;&#x2F;3.将三个参数字符串拼接成一个字符串进行sha1加密\n    var tempStr = array.join(&#x27;&#x27;);\n    const hashCode = crypto.createHash(&#x27;sha1&#x27;); &#x2F;&#x2F;创建加密类型 \n    var resultCode = hashCode.update(tempStr,&#x27;utf8&#x27;).digest(&#x27;hex&#x27;); &#x2F;&#x2F;对传入的字符串进行加密\n\n    &#x2F;&#x2F;4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\n    if(resultCode === signature){\n        res.send(echostr);\n    }else{\n        res.send(&#x27;mismatch&#x27;);\n    }\n});\n\n&#x2F;&#x2F;监听3000端口\napp.listen(3000);\n</code></pre><h3>4.部署项目</h3>\n<p>   完成了代码后我们就可以把项目发布到外网上了，这里我用的是花生壳内网映射外网的软件，各位可以随意使用其他工具。\n1.打开花生壳的软件，点击内网穿透:\n<img src=\"http://img.blog.csdn.net/20170527132325667?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"花生壳\">\n2.点击添加映射\n<img src=\"http://img.blog.csdn.net/20170527132602551?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"点击添加映射\">\n3.配置映射\n<img src=\"http://img.blog.csdn.net/20170527132805752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\">\n  由于微信只接受80端口，我们在映射类型选择为 网站80端口；内网主机就是我们电脑的 IP 地址；内网端口号就是node.js的监听端口；点击确定后，就成功映射到外网了，可以通过花生壳提供的域名进行访问。</p>\n<h3>5.接入验证</h3>\n<p>  再次进入 <a href=\"https://mp.weixin.qq.com/\">微信公众平台</a>\n在左侧菜单点击基本配置，如图：\n<img src=\"http://img.blog.csdn.net/20170527134810969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"基本配置\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170527134911235?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"修改服务器配置\"></p>\n<p>点击修改配置。其中服务器地址，就是我们外网映射的地址；令牌（Token）就是我们在 config.json 文件中 定义的 token 值；消息加密可以点击随机生成按钮，当然你也可以随便定义；消息加解密方式这块可以随便选择，这里我就使用默认的，如图：\n<img src=\"http://img.blog.csdn.net/20170527141026200?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信服务器配置\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170527141056778?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信公众平台接入\"></p>\n<p>  点击提交按钮，提示 提交成功，那么我就要祝贺你了<img src=\"http://img.blog.csdn.net/20170527141529568?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"哎呦不错哦\">\n  你已经成功的步入了Node.js开发微信的开发的第一步。</p>\n<p>   文章源代码：<a href=\"https://github.com/SilenceHVK/wechatByNode\">https://github.com/SilenceHVK/wechatByNode</a> 。对文章有不正确之处，请给予纠正。github源代码请顺手给个 Star，最后感谢您的阅读。</p>\n</div>",
    "title": "1.Node.js 接入微信公众平台开发",
    "last_reply_at": "2017-06-01T15:21:08.913Z",
    "good": false,
    "top": false,
    "reply_count": 13,
    "visit_count": 732,
    "create_at": "2017-05-27T09:50:55.270Z",
    "author": {
      "loginname": "SilenceHVK",
      "avatar_url": "https://avatars0.githubusercontent.com/u/12862565?v=3&s=120"
    }
  }, {
    "id": "5930116403dba3510d8a62bb",
    "author_id": "54475fdf649ac9220757b8ed",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>什么是好的代码？你的代码是否健壮、安全、规范、可维护？你的 Coding 能力是否在提高？\n洋葱猴今天为大家准备了一份礼物——码力值。</p>\n<p><img src=\"https://dn-coding-net-production-pp.qbox.me/158d4c72-4a06-44bd-8fdc-a283f42a1f5b.png?imageView2/2/w/500/h/500&amp;imageMogr2/format/png/ignore-error/1\" alt></p>\n<h5>Coding 知码力，来为你的代码跑个分！</h5>\n<p>码力值是基于各项编程语言，利用机器学习算法，对程序员个人经验，代码健壮性，可维护性及安全性等多方面的编码能力进行综合评测得出的评测结果。简单的说就是用程序员写的代码以及写代码过程中的行为特征而评测出来的编程能力的分数，码力值的增长需要程序员通过日积月累的编写代码点点滴滴地累积才能逐步提高。</p>\n<p>现在进入 <a href=\"https://coding.net/u\">你的 Coding 主页</a>，点击“开始评测”即可在 24 小时内得到你的码力值，然后在微博，冒泡和知乎晒出你的码力值吧；）</p>\n<h5>码力值的评测逻辑是什么?</h5>\n<p>码力值的评测逻辑采用的是 <a href=\"http://wiki.mbalib.com/zh-tw/%E8%A1%8C%E4%B8%BA%E9%9D%A2%E8%AF%95%E6%B3%95\">行为式面试 (Behavioral Interview ) </a> 的逻辑，也就是依据您过去的编写的代码以及编写代码过程中的行为特征, 来综合评测您的编程技能。</p>\n<h5>为什么显示我没有码力值?</h5>\n<p>可能的原因有如下几种情况：</p>\n<ul>\n<li>没有 push 过代码</li>\n<li>您擅长的编程语言，目前还不支持，我们正在努力，不久后, 会支持更多的编程语言．目前，评测支持的语言有: Java，JavaScript， PHP 和 Python</li>\n<li>您可能刚刚提交代码, 请耐心等待，一般代码提交后需要２－３天的时间, 才能评测出来码力值的评测结果</li>\n</ul>\n<h5>为什么上传了代码还是没有码力值?</h5>\n<p>请检查是否存在下面几种情况:</p>\n<ul>\n<li>您可能刚刚提交代码, 请耐心等待，一般代码提交后需要２－３天的时间, 才能评测出来码力值的评测结果</li>\n<li>上传的代码是否都是自己过去编写的代码, 码力值评测模型会鉴别出来哪些代码是本人编写的, 并且以此为依据进行评测</li>\n<li>如果确定上传的代码确实是自己编写的, 那么需要检查一下, 代码上传的方式是否正确: 第一次上传代码的时候, 需要以保留代码提交历史记录的方式提交代码, 详细操作参见 <a href=\"https://coding.net/help/doc/git/repository.html#section-4\">怎么从其他代码仓库导入代码</a></li>\n<li>建议使用 Coding 来做为日常工作的代码仓库, 使用一段时间后, 就会有码力值了</li>\n</ul>\n<h5>怎么从其他代码仓库导入代码</h5>\n<p>导入代码的时候, 最关键的一点就是导入代码的同时，需要<strong>保留代码提交历史记录</strong>．\n如果您是 Coding 的新用户，并且是第一次上传代码的话，最好采用 “导入项目” 的方式， 或者采用 git remote add 或者 git remote set-url 的方法导入项目， 这样的话，保留了代码提交历史记录, 会缩短码力值的测评时间，而且评分会更加全面和准确。</p>\n<h5>多长时间会有码力值?</h5>\n<p>通常在第一次上传代码后的 2 - 3 天会有码力值展示，随后码力值的数值会每周会有一次分数的更新.</p>\n<h5>为什么我的码力值很低?</h5>\n<p>可能的原因有如下几种:</p>\n<ul>\n<li>Coding 上代码量太少, 码力值与您实际技能的偏差会较大, 最理想的情况就是, 把尽可能多的代码迁移到 Coding 上, 并把 Coding 做为日常工作的代码仓库, 这样的话, 码力值的结果会更准确.</li>\n<li>错误的上传代码的方式, 比如:\n<ul>\n<li>一次性的上传大量代码, 这是无助于码力值的增长, 日积月累的使用 Coding 才会有助于提高码力值</li>\n<li>没有保留代码提交历史记录的迁移代码, 也是无助于码力值的评测的</li>\n</ul>\n</li>\n<li>代码质量低, 需要逐步提高自己, 养成好的编程习惯\n<ul>\n<li>提高代码的健壮性, 让代码在任何极端或边界条件下, 都能正常工作</li>\n<li>大道至简, 简单的代码质量会更高</li>\n<li>改掉拷贝粘贴的习惯, 将共同功能, 逻辑的代码封装起来, 提高代码的重用性</li>\n<li>认真写好注释, 过一段时间, 无论是别人还是自己, 看到这段代码的时候, 会明白为什么逻辑是这样</li>\n<li>写代码的时候, 要想一想, 将来需求变了, 修改起来容易吗? 如果要加功能, 是不是很容易</li>\n<li>多学几门语言, 开开眼界</li>\n</ul>\n</li>\n</ul>\n<h5>为什么我看不到别人的码力值? 怎么让别人看到我的码力值?</h5>\n<p>码力值的默认设置是不公开的, 需要在码力值蜘蛛图的右上角, 勾选 “允许其他人查看我的码力值” 选项,  才能让他人看到您的码力值。你也可以选择码力值页面的“晒晒分”进行分享！</p>\n<h5>码力值会泄露我的代码吗？</h5>\n<p>码力值测评工具只分析代码，只展现统计数据，不涉及任何具体的代码数据，请放心使用。</p>\n<p>Happy Coding,\n<a href=\"https://coding.net\">Coding.net</a></p>\n</div>",
    "title": "你的代码能跑多少分？Coding 知码力",
    "last_reply_at": "2017-06-01T13:06:44.151Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 138,
    "create_at": "2017-06-01T13:06:44.151Z",
    "author": {
      "loginname": "zengliqi",
      "avatar_url": "https://avatars.githubusercontent.com/u/9347370?v=3&s=120"
    }
  }, {
    "id": "592f7ac7855efbac2cf7a542",
    "author_id": "54a209198ade094b67f3fe9e",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>端午节结束了。虽然接下来的四个月都没有节假日，但笔者一点都不烦恼。因为 Node.js 8 在端午后第一个工作日就正式发布，这足以让我与 Node.js 的激情燃烧一个夏天！本文挑选了笔者认为 Node.js 8 最令人兴奋的四大新功能，与大家分享。</p>\n<h2>async/await 与 util.promisify</h2>\n<p>Node.js 一直以来的关键设计就是把用户关在一个“异步编程的监狱”里，以换取非阻塞 I/O 的高性能，让用户轻易开发出高度可扩展的网络服务器。这从 Node.js 的 API 设计上就可见一斑，很多API——如 fs.open(path, flags[, mode], callback)——要求用户必须把该操作执行成功后的逻辑放在最后参数里，作为函数传递进去；而 fs.open 本身是立即返回的，用户不能把依赖于 fs.open 结果的逻辑与 fs.open 本身线性地串联起来。</p>\n<p>在这座“异步编程的监狱”里，不掌握异步编程就寸步难行。而我们习惯性地使用线性思维去思考业务问题，却在实现的时候，被迫把业务逻辑被切成很多小片段去书写，就是一件很痛苦的事情了。为了减轻异步编程的痛苦，几年间我们见证了数个解决方案的出现：从深度嵌套的回调金字塔，到带有长长的 then() 链条的 Promise 设计模式，再到 Generator 函数，到如今 Node.js 8 的 async/await 操作符。笔者认为，所有这些解决方案中，async/await 操作符是最接近命令式编程风格的，使用起来最为自然的。</p>\n<p><img src=\"//dn-cnode.qbox.me/Flq_xl2NN0xbQB8kgEwUJUoIy0r_\" alt=\"brains.jpg\"></p>\n<p>例如我们想先创建一个文件，再读取、输出它的大小，只需三行代码：</p>\n<pre class=\"prettyprint language-js\"><code>await writeFile(&#x27;a_new_file.txt&#x27;, &#x27;hello&#x27;);\nlet result = await stat(&#x27;a_new_file.txt&#x27;);\nconsole.log(result.size);\n</code></pre><p>这简直是最简单的异步编程了！我们用自然、流畅的代码表达了线性业务逻辑，同时还得到了 Node.js 非阻塞 I/O 带来的高性能，简直是兼得了鱼和熊掌。</p>\n<p>但别着急，这段代码不是立即就可以执行的，细心的读者肯定会问：例子中的 writeFile 和 stat 分别是什么？其实它们就是标准库的 fs.writeFile 和 fs.stat，但又不完全是。这是因为 async 和 await 本质上是对 Promise 设计模式的封装，一般情况下 await 的参数应是一个返回 Promise 对象的函数。而 fs.writeFile 和 fs.stat 这些标准库 API 没有返回值（返回 undefined），需要一个方法把他们包装成返回 Promise 对象的函数。</p>\n<p>但总不能一个一个包装去吧，这样工作量堪比重写标准库了。幸好，我们观察到所有这些标准库 API 基本都满足一个共同特征：它们都是用最后一个参数来接受一个类似“ (err, value) =&gt; … ”的回调函数。于是我们就可以用一个 API 把几乎所有标准库 API 都转换为返回 Promise 对象的函数。这就是 util.promisify。利用 util.promisify，我们可以添加以下代码：</p>\n<pre class=\"prettyprint language-js\"><code>const util = require(&#x27;util&#x27;);\nconst fs = require(&#x27;fs&#x27;);\nconst writeFile = util.promisify(fs.writeFile);\nconst stat = util.promisify(fs.stat);\n</code></pre><p>若没有 util.promisify，async/await 是很难用的，因为它们需要配合 Promise 一起使用，而之前很多库函数又不返回 Promise。笔者认为 async/await 运算符和 util.promisify 的绝配，是 Node.js 8 最大的亮点。</p>\n<p>以上示例的完整代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>const util = require(&#x27;util&#x27;);\nconst fs = require(&#x27;fs&#x27;);\nconst writeFile = util.promisify(fs.writeFile);\nconst stat = util.promisify(fs.stat);\n\n(async function () {\n  await writeFile(&#x27;a_new_file.txt&#x27;, &#x27;hello&#x27;);\n  let result = await stat(&#x27;a_new_file.txt&#x27;);\n  console.log(result.size);\n})();\n</code></pre><h2>Async Hooks</h2>\n<p>调试过 Node.js 的小伙伴都知道，Node.js 一个很大的弱点就是——出错时调用栈不完整。这也是“异步编程的监狱”的设计带来的另一个缺点，因为在异步编程下，我们的代码被切成了无数个小片段，报错时只能得到一个小片段的调用栈，而全局的来龙去脉却看不到，用户只能推测是何处代码触发了何种事件导致执行了小片段，再不断往前推演。</p>\n<p>举一个简单的例子：</p>\n<pre class=\"prettyprint language-js\"><code>function IWantFullCallbacks() {\n  setTimeout(function() {\n    const localStack = new Error();\n    console.log(localStack.stack);\n  }, 1000);\n}\n\nIWantFullCallbacks();\n</code></pre><p>在这个例子中，我们模拟了 setTimeout 内出错时打印调用栈的情景。将它存为 1.js 并执行，我们期望，如果调用栈能包含外层的 IWantFullCallbacks()，并打印其行号 8，定是极好的，因为那样对我们排查错误很有帮助。但现实中却并非如此，调用栈只有四行，行号顶多打印到了第 3 行的报错本身，我们根本看不出来是第 8 行触发了这个错误。因为第 8 行作为异步调用成功地结束了，它才不关心“后事如何”。</p>\n<pre class=\"prettyprint\"><code>Error\n    at Timeout._onTimeout (&#x2F;Users&#x2F;pmq20&#x2F;1.js:3:24)\n    at ontimeout (timers.js:488:11)\n    at tryOnTimeout (timers.js:323:5)\n    at Timer.listOnTimeout (timers.js:283:5)\n</code></pre><p>而 Node.js 8 中新增的 Async Hooks 功能就可以解决这个问题。Node.js 8 中添加了四种 Async Hooks 回调，它们可以跟踪 Node.js 的所有异步资源的生命周期。这里所谓的资源是指 Node.js 底层 libuv 中的各类短期请求和长期句柄，如本例中的定时器，就是这样一个异步资源。这四种回调分别涵盖了这些异步资源的创建、回调前、回调后、销毁这四个生命阶段。</p>\n<p>通过自定义这四种回调函数，我们就可以跨调用栈来做事件追踪，我们可以先做一个 Map 容器放在回调函数的闭包里，用来作为异步资源 ID 到调试信息的映射，并在异步资源的创建时进行调试信息的累积。闭包里再声明一个 currentUid 表示目前正在执行的异步资源 ID，于回调前、回调后两个生命阶段的时机进行记录。这样下来，第 8 行执行 IWantFullCallbacks() 的时候创建的异步资源的 ID，与后期定时器到期自行回调的异步资源的 ID，是同一个 ID，因而可以起到跨调用栈累积调试信息的作用。我们通过 Node.js 8 的 async_hooks 的 createHook API 来创建回调，并通过 enable() 方法注册并执行，代码如下：</p>\n<pre class=\"prettyprint language-js\"><code>const stack = new Map();\nstack.set(-1, &#x27;&#x27;);\nlet currentUid = -1;\n\nfunction init(id, type, triggerId, resource) {\n  const localStack = (new Error()).stack.split(&#x27;\\n&#x27;).slice(1).join(&#x27;\\n&#x27;);\n  const extraStack = stack.get(triggerId || currentUid);\n  stack.set(id, localStack + &#x27;\\n&#x27; + extraStack);\n}\nfunction before(uid) {\n  currentUid = uid;\n}\nfunction after(uid) {\n  currentUid = -1;\n}\nfunction destroy(uid) {\n  stack.delete(uid);\n}\n\nconst async_hooks = require(&#x27;async_hooks&#x27;);\nconst hook = async_hooks.createHook({init, before, after, destroy});\nhook.enable();\n</code></pre><p>最后我们修改定时器的回调内容，让它输出 Map 中累积的调试信息：</p>\n<pre class=\"prettyprint language-js\"><code>function IWantFullCallbacks() {\n  setTimeout(function() {\n    const localStack = new Error();\n    console.log(localStack.stack);\n    console.log(&#x27;---&#x27;);\n    console.log(stack.get(currentUid));\n  }, 1000);\n}\n</code></pre><p>这次的效果如下：</p>\n<pre class=\"prettyprint\"><code>Error\n    at Timeout._onTimeout (&#x2F;Users&#x2F;pmq20&#x2F;2.js:26:24)\n    at ontimeout (timers.js:488:11)\n    at tryOnTimeout (timers.js:323:5)\n    at Timer.listOnTimeout (timers.js:283:5)\n---\n    at init (&#x2F;Users&#x2F;pmq20&#x2F;2.js:6:23)\n    at runInitCallback (async_hooks.js:459:5)\n    at emitInitS (async_hooks.js:327:7)\n    at new Timeout (timers.js:592:5)\n    at createSingleTimeout (timers.js:472:15)\n    at setTimeout (timers.js:456:10)\n    at IWantFullCallbacks (&#x2F;Users&#x2F;pmq20&#x2F;2.js:25:3)\n    at Object.&lt;anonymous&gt; (&#x2F;Users&#x2F;pmq20&#x2F;2.js:33:1)\n    at Module._compile (module.js:569:30)\n    at Object.Module._extensions..js (module.js:580:10)\n</code></pre><p>可见，我们以同一个异步资源的 ID 为线索，把两次的调用栈都完整保留了。</p>\n<p>但这只是 Node.js 8 的 Async Hooks 的用途之一，有了这个功能，我们甚至可以来测量一些事件各个阶段所花费的时间。只要我们有异步资源 ID 这枚钥匙，配合回调函数，就可以在事件循环的多个周期那看似毫无头绪的执行过程中，筛选出有用的信息。</p>\n<h2>Node.js API (N-API)</h2>\n<p>经历过 Node.js 大版本升级的同学肯定会发现，每次升级后我们都得重新编译像 node-sass 这种用 C++ 写的扩展模块，否则会遇到下面这样的报错，</p>\n<pre class=\"prettyprint\"><code>Error: The module &#x27;node-sass&#x27;\nwas compiled against a different Node.js version using\nNODE_MODULE_VERSION 51. This version of Node.js requires\nNODE_MODULE_VERSION 55. Please try re-compiling or re-installing\nthe module (for instance, using &#96;npm rebuild&#96; or &#96;npm install&#96;).\n</code></pre><p>NODE_MODULE_VERSION 是每一个 Node.js 版本内人为设定的数值，意思为 ABI 的版本号。一旦这个号码与已经编译好的二进制模块的号码不符，便判断为 ABI 不兼容，需要用户重新编译。</p>\n<p>这其实是一个工程难题，亦即 Node.js 上游的代码变化如何最小地降低对 C++ 模块的影响，从而维持一个良好的向下兼容的模块生态系统。最坏的情况下，每次发布 Node.js 新版本，因为 API 的变化，C++ 模块的作者都要修改它们的源代码，而那些不再有人维护或作者失联的老模块就会无法继续使用，在作者修改代码之前社区就失去了这些模块的可用性。其次坏的情况是，每次发布 Node.js 新版本，虽然 API 保持兼容使得 C++ 模块的作者不需要修改他们的代码，但 ABI 的变化导致必须这些模块必须重新编译。而最好的情况就是，Node.js 新版本发布后，所有已编译的 C++ 模块可以继续正常工作，完全不需要任何人工干预。</p>\n<p>Node.js Compiler 也面临同样的问题，之前 nodec 强制用户编译环境中的 Node.js 版本与编译器的内置 Node.js 版本一致，就是为了消除编译时与运行时 C++ 模块的版本不兼容问题，但这也给用户带来了使用的不便。见： <a href=\"https://github.com/pmq20/node-compiler/issues/27\">https://github.com/pmq20/node-compiler/issues/27</a>  如果能做到上述最好的情况，那么这个问题也就完美解决了。</p>\n<p>Node.js 8 的 Node.js API (N-API) 就是为了解决这个问题，做到上述最好的情况，为 Node.js 模块生态系统的长期发展铺平道路。N-API 追求以下目标：</p>\n<ol>\n<li>有稳定的 ABI</li>\n<li>抽象消除 Node.js 版本之间的接口差异</li>\n<li>抽象消除 V8 版本之间的接口差异</li>\n<li>抽象消除 V8 与其他 JS 引擎（如 ChakraCore）之间的接口差异</li>\n</ol>\n<p>笔者观察到，N-API 采取以下手段达到上述目标：</p>\n<ol>\n<li>采用 C 语言头文件而不是 C++，消除 Name Mangling 以便最小化一个稳定的 ABI 接口</li>\n<li>不使用 V8 的任何数据类型，所有 JavaScript 数据类型变成了不透明的 napi_value</li>\n<li>重新设计了异常管理 API，所有 N-API 都返回 napi_status，通过统一的手段处理异常</li>\n<li>重新了设计对象的生命周期 API，通过 napi_open_handle_scope 等 API 替代了 v8 的 Scope 设计</li>\n</ol>\n<p>N-API 目前在 Node.js 8 仍是实验阶段的功能，需要配合命令行参数 --napi-modules 使用。</p>\n<h2>TurboFan 与 Ignition (TF+I)</h2>\n<p>Node.js 8 得益于将 v8 升级到了 5.8，引入了 TurboFan 与 Ignition 的支持。关于 Ignition 的详细介绍，请见 <a href=\"https://cnodejs.org/topic/59084a9cbbaf2f3f569be482\">https://cnodejs.org/topic/59084a9cbbaf2f3f569be482</a></p>\n<p>前面已经提到，如今借助 Node.js 8 我们可以用 await/async 书写程序，但并未提到异常处理，其实 await/async 的异常处理多借助 try/catch 配合使用。而在以前的 Node.js 版本中，try/catch 是个昂贵的操作，性能并不高。这主要是由于 v8 内老的 Crankshaft 不易优化这些 ES5 的新语法。但随着 TF+I 新架构的引入，try/catch 的写法也可以得到优化，作为用户就可以高枕无忧的使用 await/async + try/catch 了。</p>\n<p>目前 Node.js 8 内的 v8 版本仅更新到了 5.8，TF+I 需要配合命令行参数 --turbo --ignition 使用。一旦升级到 v8 5.9，TF+I 将会默认开启。</p>\n</div>",
    "title": "端午节后福利：Node.js 8",
    "last_reply_at": "2017-06-01T12:33:47.488Z",
    "good": true,
    "top": false,
    "reply_count": 10,
    "visit_count": 658,
    "create_at": "2017-06-01T02:24:07.258Z",
    "author": {
      "loginname": "pmq20",
      "avatar_url": "https://avatars1.githubusercontent.com/u/13315?v=3&s=120"
    }
  }, {
    "id": "592e987f855efbac2cf7a51e",
    "author_id": "53a8cadda087f4562002c4cf",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>Node.js 8 新鲜出炉，其实有一个特别有意思的更新：N-API。这个是用 C/C++ 来写原生插件的，之前 Node.js 是绑死 v8 的，这个原生插件编写接口也就是有不少 v8 内存和对象模型的细节也混杂其中。现在微软联手 IBM/Intel/Mozzilla/NodeSource 把 node-chakracore 搞定了，自然就有动力净化一下这个接口了，不然总拿 chakra-shim 仿那一改得飞快的 v8 接口实在是心累。\nN-API 的文档见 <a href=\"https://nodejs.org/api/n-api.html\">Node.js v8.0.0 Documentation</a> ，可以看出它是一个纯 C 的 API。</p>\n<p>好在，Nan 项目已经第一时间进行了封装，现有的 Nan 项目以后应该直接就能用 N-API 编译使用了，呼，还好。</p>\n<p>在里有一堆官方的PoC示例：<a href=\"https://github.com/nodejs/abi-stable-node-addon-examples\">nodejs/abi-stable-node-addon-examples</a> 。如果只想有个直观感受，看这个视频也凑合：<a href=\"https://youtu.be/zGmQR7iBfD4?list=PLfMzBWSH11xYaaHMalNKqcEurBH8LstB8&amp;t=989\">Node.js &amp; ChakraCore by Arunesh Chandra, Microsoft</a>\n– 同时发在 <a href=\"https://zhuanlan.zhihu.com/p/27182548\">知乎机构号</a> ，欢迎关注。</p>\n</div>",
    "title": "Node.js 8 来了，带了 N-API",
    "last_reply_at": "2017-06-01T11:47:22.355Z",
    "good": false,
    "top": false,
    "reply_count": 5,
    "visit_count": 552,
    "create_at": "2017-05-31T10:18:39.725Z",
    "author": {
      "loginname": "pinxue",
      "avatar_url": "https://avatars3.githubusercontent.com/u/958237?v=3&s=120"
    }
  }, {
    "id": "592fb50d2cace39d0de58adf",
    "author_id": "591be580ba8670562a40f1f1",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>通过npm install jsonwebtoken安装，调用它的sign可以生成一个具有过期时间的token，使用verify可以验证token是否有效。但是发现该模块不具有refresh token的机制，那么该如何在token过期之前，刷新token？</p>\n</div>",
    "title": "node使用jwt，如何刷新token",
    "last_reply_at": "2017-06-01T11:46:35.868Z",
    "good": false,
    "top": false,
    "reply_count": 13,
    "visit_count": 231,
    "create_at": "2017-06-01T06:32:45.240Z",
    "author": {
      "loginname": "broncoss",
      "avatar_url": "https://avatars0.githubusercontent.com/u/18042823?v=3&s=120"
    }
  }, {
    "id": "57cfdc863cfda47b2c233112",
    "author_id": "574313b66be4d220710d7c6a",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fme14oUIqP72fu297mt9Y8Tb2c2y\" alt=\"QQ20160907-0.png\"></p>\n<p>如图，这是截取的template中的一部分，template 中的html代码，link 的css 文件都是会被加载的\n但是像这种script 标签中的 js代码并不会执行,\nscript src 也不会请求，请问应该如何做到可以执行javascript 代码。</p>\n</div>",
    "title": "vue.js  template中如果想包含script代码，应该怎样处理",
    "last_reply_at": "2017-06-01T11:46:10.094Z",
    "good": false,
    "top": false,
    "reply_count": 11,
    "visit_count": 3485,
    "create_at": "2016-09-07T09:23:18.154Z",
    "author": {
      "loginname": "xunull",
      "avatar_url": "https://avatars.githubusercontent.com/u/11656961?v=3&s=120"
    }
  }, {
    "id": "590ac0965bb7efe417431feb",
    "author_id": "57987e242d740f7c26637f06",
    "tab": "job",
    "content": "<div class=\"markdown-text\"><p><img src=\"https://i.v2ex.co/lSC6b74q.jpeg\" alt>\n<img src=\"https://i.v2ex.co/4AKd5S3B.jpeg\" alt>\n<img src=\"https://i.v2ex.co/rK4KefLh.jpeg\" alt>\n<img src=\"https://i.v2ex.co/43BYY6Ba.jpeg\" alt>\n<img src=\"https://i.v2ex.co/Y6nRNEo9.jpeg\" alt>\n<img src=\"https://i.v2ex.co/dlSxWAyL.jpeg\" alt>\n<img src=\"https://i.v2ex.co/1791jiWV.jpeg\" alt>\n<img src=\"https://i.v2ex.co/u941vIkY.jpeg\" alt>\n<img src=\"https://i.v2ex.co/fT8CjeT3.png\" alt>\n<img src=\"https://i.v2ex.co/6E3D6Lw5.png\" alt>\n<img src=\"https://i.v2ex.co/U8LY7ydO.jpeg\" alt>\n<img src=\"https://i.v2ex.co/i61E5K1d.jpeg\" alt></p>\n</div>",
    "title": "[杭州] Fireball Team | 寻找后端开发工程师加入",
    "last_reply_at": "2017-06-01T11:36:38.831Z",
    "good": false,
    "top": false,
    "reply_count": 18,
    "visit_count": 1886,
    "create_at": "2017-05-04T05:48:06.449Z",
    "author": {
      "loginname": "ufo22940268",
      "avatar_url": "https://avatars3.githubusercontent.com/u/848704?v=3&s=120"
    }
  }, {
    "id": "592e5e52855efbac2cf7a4f6",
    "author_id": "591a9037d371b6372a8afa48",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><strong>项目背景</strong></p>\n<p>这个项目主要是为了玩玩NodeJS，项目的方向大概是做出类似QQ的在线聊天系统。想要在线体验可以点击<a href=\"http://47.93.252.247:8088/\">在线演示</a>。</p>\n<p>项目使用PM2进行部署和管理，功能在不断的迭代开发中。如果你觉得这个项目比较有趣，或者能对你有所帮助，欢迎给个Star。</p>\n<p>项目地址：<a href=\"https://github.com/bergwhite/nodejs-chat\">https://github.com/bergwhite/nodejs-chat</a></p>\n<p>PS: 最近找工作，北京的欢迎联系。另外之前做过一个基于Vue全家桶二次开发的V2EX社区 <a href=\"https://github.com/bergwhite/v2ex-vue\">https://github.com/bergwhite/v2ex-vue</a>。</p>\n<p><strong>项目目录</strong></p>\n<pre class=\"prettyprint\"><code>\n├─bin\n│    www  &#x2F;&#x2F; 启动express\n├─database\n│    index.js  &#x2F;&#x2F; MongoDB\n├─public  &#x2F;&#x2F; 静态文件\n│    css\n│        index.css  &#x2F;&#x2F; 首页CSS\n│    js\n│        index.js  &#x2F;&#x2F; 与socket服务进行通讯（关键文件）\n|        socket-server.js  &#x2F;&#x2F; socket服务（关键文件）\n│    img\n├─routers\n│    index.js  &#x2F;&#x2F; 页面路由\n├─view\n│    error.ejs  &#x2F;&#x2F; 错误页\n│    index.ejs  &#x2F;&#x2F; 首页\n│    userCenter.ejs  &#x2F;&#x2F; 用户中心（规划中）\n│    userList.ejs  &#x2F;&#x2F; 用户列表（规划中）\n├─app.js  &#x2F;&#x2F; express\n├─package.json  &#x2F;&#x2F; npm包\n\n</code></pre><p><strong>路由</strong></p>\n<p>目前只有/目录和/room/:id正式使用了，其他路由的页面还在迭代开发中。</p>\n<pre class=\"prettyprint\"><code>\n&#x2F;  &#x2F;&#x2F; 首页\n&#x2F;user  &#x2F;&#x2F; 用户列表\n&#x2F;user&#x2F;:id  &#x2F;&#x2F; 用户中心\n&#x2F;user&#x2F;:id&#x2F;register  &#x2F;&#x2F; 注册（JSON）\n&#x2F;user&#x2F;:id&#x2F;login  &#x2F;&#x2F; 登陆（JSON）\n&#x2F;user&#x2F;:id&#x2F;logout  &#x2F;&#x2F; 注销（JSON）\n&#x2F;user&#x2F;:id&#x2F;info  &#x2F;&#x2F; 用户资料（JSON）\n&#x2F;room&#x2F;:id  &#x2F;&#x2F; 指定聊天室\n\n</code></pre><p><strong>开始安装</strong></p>\n<p>使用之前，请在package.json中修改MongoDB的安装路径（–dbpath）。</p>\n<pre class=\"prettyprint\"><code>\ngit clone https:&#x2F;&#x2F;github.com&#x2F;bergwhite&#x2F;nodejs-chat  &#x2F;&#x2F; 克隆项目到本地\ncd nodejs-chat  &#x2F;&#x2F; 进入项目目录\nnpm install  &#x2F;&#x2F; 安装依赖\nnpm run build  &#x2F;&#x2F; 构建线上代码\nnpm run mongod &#x2F;&#x2F; 启动MongoDB服务\nnpm run start &#x2F;&#x2F; 启动聊天室服务并启动网站\n\n</code></pre><p><strong>项目演示</strong></p>\n<p>目前项目存在一个已知的bug，表情包无法在div模拟的输入框中插入（修复中）。</p>\n<p>匿名聊天</p>\n<p><img src=\"http://atmp.oss-cn-qingdao.aliyuncs.com/img/nodejs-chat-nick-chat.gif\" alt=\"nodejs-chat-nick-chat\"></p>\n<p>用户聊天</p>\n<p><img src=\"http://atmp.oss-cn-qingdao.aliyuncs.com/img/nodejs-chat-user-chat.gif\" alt=\"nodejs-chat-user-chat\"></p>\n<p>成员&amp;房间</p>\n<p><img src=\"http://atmp.oss-cn-qingdao.aliyuncs.com/img/nodejs-chat-memb-room.gif\" alt=\"nodejs-chat-memb-room\"></p>\n<p>离线通知</p>\n<p><img src=\"http://atmp.oss-cn-qingdao.aliyuncs.com/img/nodejs-chat-user-gone.gif\" alt=\"nodejs-chat-user-gone\"></p>\n<p>更多房间</p>\n<p><img src=\"http://atmp.oss-cn-qingdao.aliyuncs.com/img/nodejs-chat-more-rooms.gif\" alt=\"nodejs-chat-more-rooms\"></p>\n<p>房间独立</p>\n<p><img src=\"http://atmp.oss-cn-qingdao.aliyuncs.com/img/nodejs-chat-room-diff.gif\" alt=\"nodejs-chat-room-diff\"></p>\n<p><strong>已上线功能</strong></p>\n<ul>\n<li>跨浏览器，跨地域聊天（SocketIO自带技能）</li>\n<li>首次进入会显示欢迎信息</li>\n<li>发送空消息会进行提示</li>\n<li>直接发送消息默认昵称为“神秘人”</li>\n<li>发送消息后会清空当前输入框内容，然后焦点回到消息输入框</li>\n<li>添加用户名后会成为新用户，然后告知全房间人有新用户加入</li>\n<li>可以创建不同的房间，不同的房间的聊天是相互独立的</li>\n<li>显示当前房间的在线用户（设置了用户名的）</li>\n<li>显示目前所有打开的房间</li>\n<li>用户（设置了用户名的）离线会通知所有房间内的成员</li>\n<li>压缩线上代码，加快访问速度</li>\n<li>…</li>\n</ul>\n<p><strong>待上线功能</strong></p>\n<p>用户名</p>\n<ul>\n<li>统计匿名用户</li>\n<li>支持一键随机获取用户名</li>\n</ul>\n<p>头像</p>\n<ul>\n<li>访客使用默认头像</li>\n<li>新用户（设置了用户名的）随机获得一个头像</li>\n<li>新用户换头像可以从默认的一组头像中选择</li>\n<li>是否支持上传头像还在考虑中（安全性问题）</li>\n</ul>\n<p>聊天</p>\n<ul>\n<li>支持多组丰富的表情包</li>\n<li>是否支持上传图片还在考虑中（安全性问题）</li>\n</ul>\n<p>数据库</p>\n<ul>\n<li>对接MongoDB，新用户（设置了用户名的）设置密码后，将从临时用户转变为正式用户</li>\n</ul>\n<p><strong>项目缺陷</strong></p>\n<ul>\n<li>界面丑（等功能完善了再考虑）</li>\n<li>表情包无法在div模拟的输入框中插入（修复中）</li>\n<li>…</li>\n</ul>\n</div>",
    "title": "用NodeJS打造多人在线聊天室（NodeJS & SocketIO & Express & EJS & MongoDB & Gulp）",
    "last_reply_at": "2017-06-01T11:28:17.011Z",
    "good": false,
    "top": false,
    "reply_count": 11,
    "visit_count": 437,
    "create_at": "2017-05-31T06:10:26.725Z",
    "author": {
      "loginname": "bergwhite",
      "avatar_url": "https://avatars3.githubusercontent.com/u/22515009?v=3&s=120"
    }
  }, {
    "id": "58fcb4d931e8c2bb1c3dcd28",
    "author_id": "58de137bb3e60b982d089da5",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><blockquote>\n<p>因为最近一直在准备面试和笔试，所以开始看一些基础的知识，并试着回答一下 <a href=\"https://github.com/ElemeFE/node-interview\">饿了么大前端</a> 的nodejs问题。文中主要展示我在学习过程中查看的文章地址，并做了一些归纳，添加上了一些我自己的看法。有一些问题也还没有得到解决，如果大家有好的答案可以直接留言。</p>\n</blockquote>\n<h2>Javascript基础问题</h2>\n<h3>类型判断</h3>\n<ul>\n<li>undefined &amp; null ： <a href=\"http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html\">undefined与null的区别</a>\n<ul>\n<li>在 <code>if</code> 中，<code>undefined</code> 和 <code>null</code> 都自动转译为 <code>false</code>。</li>\n<li>在转换为数字的过程中，<code>undefined</code> 转译为 <code>NaN</code>， <code>null</code> 转译为0。</li>\n<li><strong><code>null</code> 表示&quot;没有对象&quot;，即该处不应该有值。</strong></li>\n<li><strong><code>undefined</code> 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。</strong></li>\n<li>至于为什么 <code>undefined == null</code> 为true，参见 <strong>引用传递</strong> 部分</li>\n</ul>\n</li>\n</ul>\n<h3>作用域</h3>\n<ul>\n<li><a href=\"http://www.jianshu.com/p/efe38b392f53\">你不懂JS：作用域与闭包 第一章：什么是作用域？</a>\n<ul>\n<li>作用域是一组规则，它决定了在哪里和如何查找一个变量（标识符）。这种查询也许是为了向这个变量赋值，这时变量是一个LHS引用，或者是为取得它的值，这时变量是一个RHS引用。</li>\n<li>LHS引用得自赋值操作。作用域 相关的赋值可以通过 <code>=</code> 操作符发生，也可以通过向函数参数传递（赋予）参数值发生</li>\n<li>JavaScript<strong>引擎</strong>在执行代码之前首先会编译它，这样做，它将 <code>var a = 2;</code> 这样的语句分割为两个分离的步骤：\n<ul>\n<li>首先，<code>var a</code> 在当前 作用域 中声明。这是在最开始，代码执行之前实施的。</li>\n<li>稍后，<code>a = 2</code> 查找这个变量（LHS引用），并且如果找到就向它赋值。</li>\n</ul>\n</li>\n<li>如果RHS查询在嵌套的<strong>作用域</strong>的任何地方都找不到一个值，这会导致<strong>引擎</strong>抛出一个 <code>ReferenceError</code>；如果LHS查询在嵌套的作用域的任何地方都找不到一个值，而且如果程序没有运行在 <code>Strict</code> 模式下，那么<strong>全局作用域</strong>中会创建一个变量并将它交给<strong>引擎</strong>。如果是在 <code>Strict</code> 模式下，则也会抛出 <code>ReferenceEroor</code>。</li>\n<li>如果RHS查询的值被找到了，但是你试着去做一些它做不到的事情，比如引用 <code>null</code> 或者 <code>undefined</code> 的属性，那么引擎会抛出错误 <code>TypeError</code>。</li>\n</ul>\n</li>\n<li><a href=\"http://www.jianshu.com/p/6d5f7b31892e\">你不懂JS：作用域与闭包 第二章：词法作用域</a>\n<ul>\n<li>词法作用域意味着作用域是由编写时函数被声明的位置的决策定义的。编译器的词法分析阶段实质上可以知道所有的标识符是在哪里和如何声明的，并如此在执行期间预测它们将如何被查询。</li>\n<li>在JavaScript中有两种机制可以“欺骗”词法作用域：<code>eval(..)</code> 和 <code>with</code> 。前者可以通过对一个拥有一个或多个声明的“代码”字符串进行求值，来（在运行时）修改现存的词法作用域。后者实质上是通过将一个对象引用看作一个“作用域”，并将这个对象的属性看作作用域中的标识符，（同样，也是在运行时）创建一个全新的词法作用域。</li>\n<li>这些机制的缺点是，它压制了引擎在作用域查询上进行编译期优化的能力，因为引擎不得不悲观地假定这样的优化是不合法的。这两种特性的结果就是代码将会运行的更慢。不要使用它们。</li>\n</ul>\n</li>\n<li><a href=\"http://www.jianshu.com/p/f71a92ef5fb5\">你不懂JS：作用域与闭包 第三章：函数与块儿作用域</a>\n<ul>\n<li>在JavaScript中函数是最常见的作用域单位。在另一个函数内部声明的变量和函数，实质上对任何外围“作用域”都是“隐藏的”，这是优秀软件的一个有意的设计原则。</li>\n<li>但是函数绝不是唯一的作用域单位。块儿作用域指的是这样一种想法：变量和函数可以属于任意代码块儿（一般来说，就是任意的 <code>{ .. }</code> ），而不是仅属于外围的函数。</li>\n<li>从ES3开始，<code>try/catch</code> 结构在 <code>catch</code> 子句上拥有块儿作用域。</li>\n<li>在ES6中，引入了 <code>let</code> 关键字（ <code>var</code> 关键字的表兄弟）允许在任意代码块中声明变量。<code>if (..) { let a = 2; }</code>将会声明变量a，而它实质上劫持了 <code>if</code> 的 <code>{ .. }</code> 块儿的作用域，并将自己附着在这里。</li>\n<li>虽然有些人对此深信不疑，但是块儿作用域不应当被认为是 <code>var</code> 函数作用域的一个彻头彻尾的替代品。两种机能是共存的，而且开发者们可以并且应当同时使用函数作用域和块儿作用域技术 —— 在它们各自可以产生更好，更易读/易维护代码的地方。</li>\n</ul>\n</li>\n<li><a href=\"http://www.jianshu.com/p/fcb8c23df9a2\">你不懂JS：作用域与闭包 第四章：提升</a>\n<ul>\n<li>我们可能被诱导而将 <code>var a = 2</code> 看作是一个语句，但是JavaScript 引擎 可不这么看。它将 <code>var a</code> 和 <code>a = 2</code>看作两个分离的语句，第一个是编译期的任务，而第二个是执行时的任务。这将导致在一个作用域内的所有声明，不论它们出现在何处，都会在代码本身被执行前 首先 被处理。你可以将它可视化为声明（变量与函数）被“移动”到它们各自的作用域顶部，这就是我们所说的“提升”。</li>\n<li>声明本身会被提升，但不是赋值，即便是函数表达式的赋值，也不会被提升。</li>\n<li>函数的提升是优先于变量的提升的，所以在进行重名赋值的时候需要注意。</li>\n</ul>\n</li>\n<li><a href=\"http://www.jianshu.com/p/867cbe73d534\">你不懂JS：作用域与闭包 第五章：作用域闭包</a>\n<ul>\n<li>闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。</li>\n<li>模块要求两个关键性质：\n<ul>\n<li>1）一个被调用的外部包装函数，来创建外围作用域。</li>\n<li>2）这个包装函数的返回值必须包含至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3>引用传递</h3>\n<ul>\n<li>\n<p><a href=\"http://www.cnblogs.com/cxying93/p/6106469.html\">JavaScript中基本数据类型和引用数据类型的区别</a></p>\n<ul>\n<li>基本数据类型因为值的大小固定，所以直接保存在栈内存中。而引用数据类型因为值的大小不固定，所以保存在堆内存中，而堆内存是无法直接进行访问的，进而在栈内存当中又保存了指向堆内存中位置的指针。</li>\n<li>复制时，基本数据类型是将原始值的副本赋值给新值，从而两个值之间并不会有任何影响，而引用数据类型则是将栈内存中保存的指向堆内存的指针赋值给新值，从而会互相影响。</li>\n</ul>\n</li>\n<li>\n<p>如何编写一个 json 对象的拷贝函数</p>\n<ul>\n<li>\n<p><a href=\"http://jerryzou.com/posts/dive-into-deep-clone-in-javascript/\">深入剖析 JavaScript 的深复制</a></p>\n</li>\n<li>\n<p>最简单暴力的方法是：</p>\n<pre class=\"prettyprint\"><code>let a = { x: 10, y: [20, 5]}\n\nlet b = JSON.parse(JSON.stringify(a))\n</code></pre><p><strong>但是这样不能拷贝函数，并且会丢失原型链。</strong></p>\n</li>\n<li>\n<p>较为完善的方法就是实现一个 <code>extend</code> 方法，递归调用 <code>extend</code> 方法。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"https://www.zhihu.com/question/31442029\">Javascript 中 == 和 === 区别是什么？</a></p>\n<ul>\n<li><code>===</code> 比较不同数据类型时，直接返回false。比较基本数据类型时比较的是数据类型以及值，在比较引用数据类型时是比较的是否指向同一块内存区域。</li>\n<li><code>==</code> 在比较相同数据类型的值的时候与 <code>===</code> 相同，在比较不同数据类型时，会先对两边的数据类型进行转换再比较。</li>\n</ul>\n</li>\n<li>\n<p><a href=\"http://www.cnblogs.com/youxin/p/3354903.html\">JS 中没有按地址（引用）传递，只有按值传递</a></p>\n<ul>\n<li>这里严格的说，在和JAVA类似的语言中，已经没有了指针。在C里面，指针就是一个具有固定长度的类型(在大多数的C编译器里是2个字节)，但在JAVA类似的语言里，引用也有自己的属性和方法，只是你不能直接去访问和控制它，所以它从某种意义上也是一种对象，这种机制也很大程度的避免了内存泄露，术语称之为内存结构化访问机制。</li>\n</ul>\n</li>\n</ul>\n<h3>内存释放</h3>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000000440270\">浅谈V8引擎中的垃圾回收机制</a>\n<ul>\n<li>\n<p>新生代</p>\n<ul>\n<li>内存区域小，垃圾回收频繁，大多数变量刚被声明的时候都先进入新生代区域。当新生代区域内存满的时候会进行一次清理。</li>\n<li>采用<strong>Scavenge</strong>算法进行回收，主要思想是将内存区分为 <code>From</code> 空间和 <code>To</code> 空间。变量一来时都先进入 <code>From</code> 空间，当开始清理的时候对 <code>From</code> 空间进行宽搜，将那些能够从<strong>ROOT节点</strong>搜索到的，并且还在新生代区域的变量放入 <code>To</code> 空间中，然后交换 <code>From</code> 和 <code>To</code> 空间。</li>\n</ul>\n</li>\n<li>\n<p>晋升</p>\n<ul>\n<li>在新生代区域进行回收的时候，查看这个变量是否已经经历过一次垃圾回收，如果已经经历过一次了就将它放入老生代区域。</li>\n<li>对象从 <code>From</code> 空间复制到 <code>To</code> 空间时，如果<code>To</code> 空间已经被使用了超过25%，那么这个对象直接被复制到老生代。<strong>（这里我存在疑问）</strong></li>\n</ul>\n</li>\n<li>\n<p>老生代</p>\n<ul>\n<li>内存区域大，垃圾回收频率较低，保存的对象大多数是生存周期很长的甚至是常驻内存的对象。</li>\n<li>采用<strong>Mark-Sweep（标记清除）<strong>与 <strong>Mark-Compact（标记整理）<strong>结合的算法进行回收，主要思想是进行宽搜，搜索过程当中对对象进行染色，最后如果一个对象没有被染色那么就是垃圾（这里其实和</strong>Scavenge</strong>寻找垃圾的思路是一致的，就是看一个对象能不能从</strong>ROOT节点</strong>搜索到）。然后进行对象的清除，当空间不足以分配从新生代晋升过来的对象时，才使用标记整理（其实就是内存页面的整理）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>对于文中提到的三种情况：</strong> 我还没得到确定的答案，得到后会第一时间更新。</li>\n</ul>\n<h3>ES6 新特性</h3>\n<p><a href=\"http://es6.ruanyifeng.com/\">ECMAScript 6 入门</a></p>\n<h4><code>let</code> 与 <code>var</code> 的区别</h4>\n<ul>\n<li><code>let</code> 不会有<strong>作用域提升</strong>现象，所以使用 <code>let</code> 会有<strong>TDZ错误</strong>。</li>\n<li><code>let</code> 一般与 <code>{}</code> 块联合使用，即在块中使用 <code>let</code> 声明的变量只在块中有效，在外面不能进行访问。</li>\n<li><code>let</code> 与 <code>for</code> 联合使用的时候，因为 <code>let</code> 声明的变量只在块中有效，所以每一次循环当中都会声明一个新的循环变量。<strong>（这里还需要注意，<code>for</code> 循环当中，循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域）</strong></li>\n<li><code>let</code> 不允许重复声明。</li>\n</ul>\n<h4><code>function</code> 与 <code>=&gt;</code> 的区别</h4>\n<ul>\n<li>\n<p>函数体内的 <code>this</code> 对象，就是定义时所在的对象，而不是使用时所在的对象。</p>\n<pre class=\"prettyprint\"><code>function foo() {\n  setTimeout(() =&gt; {\n    console.log(&#x27;id:&#x27;, this.id);\n  }, 100);\n}\n\nvar id = 21;\n\nfoo.call({ id: 42 });\n</code></pre></li>\n</ul>\n<p><code>setTimeout</code> 的参数是一个箭头函数，这个箭头函数的定义生效是在 <code>foo</code> 函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时 <code>this</code> 应该指向全局对象 <code>window</code>，这时应该输出 <code>21</code> 。但是，箭头函数导致 <code>this</code> 总是指向函数定义生效时所在的对象，所以输出的是 <code>42</code> 。</p>\n<ul>\n<li>不可以当做构造函数，也就是说，不可以使用 <code>new</code> 命令，否则会抛出错误。</li>\n<li>不可以使用 <code>arguments</code> 对象，该对象在函数体内不存在。</li>\n<li>不可以使用 <code>yield</code> 命令，因此箭头函数不能用作 <code>Generator</code> 函数。</li>\n</ul>\n<h4><code>const</code> 定义的 <code>Array</code> 中间元素能否被修改? 如果可以, 那 <code>const</code> 修饰对象有什么意义?</h4>\n<ul>\n<li><code>const</code> 定义的 <code>Array</code> 中间元素能被修改，<code>const</code> 定义的变量只是持有 <code>Array</code> 的地址，这个变量只是本身不能修改，而对于存在于堆内存中的 <code>Array</code> 本身是可以修改的。</li>\n<li>对于 <code>const</code> 声明，只是它的赋值操作被冻结了，而值不会因为 <code>const</code> 而不变。<strong>主要是预防在coding过程中的coder因为疏忽对变量的意外修改。</strong></li>\n</ul>\n<h4>结合 <code>{}</code> 来谈 <code>set</code> 与 <code>map</code></h4>\n<ul>\n<li><strong>Set：</strong> 感觉这个应该结合 <code>[]</code> 来谈，这个与数组的区别就是里面不存在重复的元素。结合 <code>...</code> 可以直接转为数组，并且可以很方便的实现 <strong>并集</strong>、<strong>交集</strong>、<strong>差集</strong>。（这里的问题是 <code>NaN</code> 被判为同一种元素，但是 <code>===</code> 判NaN是不同的元素）</li>\n<li><strong>WeakSet：</strong> 对象成员版的 <code>Set</code>，里面的成员只能是对象。并且这里是对成员是弱引用，所以不具有 <code>size</code> 属性，也不具有循环操作。</li>\n<li><strong>Map：</strong> 这个与 <code>{}</code> 的区别是键值可以不只是字符串了，<strong>但是这里判断两个键一不一样的时候，对于引用数据来说是看他们是否指向同一块内存。</strong></li>\n<li><strong>WeakMap：</strong> 对象键值版的 <code>Map</code>，里面的成员的键只能是对象，这边同样是弱引用。特征与 <code>WeakSet</code> 相似。</li>\n<li>以上配合 <code>...</code> 使用非常的优雅。</li>\n</ul>\n<h4>私有化的问题与 <code>symbol</code> 、 <code>class</code></h4>\n<ul>\n<li>\n<p><code>symbol</code> 是用来处理属性名的冲突。但是一个 <code>symbol</code> 属性作为键名时是不能被 <code>Object.keys()</code> 、 <code>Object.getOwnPropertyNames()</code> 获取，所以就造成了一种非私有的内部方法效果。<code>symbol</code> 是不能达到闭包那么好的效果的，因为通过 <code>Symbol.for()</code> 是可以获取同一个 <code>Symbol</code> 值的，获得以后一样是能够访问值。</p>\n</li>\n<li>\n<p>在 <code>class</code> 中实现私有方法的办法是将方法声明在类外，然后在类中使用 <code>.call()</code> 进行引用。虽然通过这个类对象是不能访问这个方法，但是这个方法其实还是暴露在其他更大的作用域当中的，或者就是使用 <code>symbol</code> 作为方法名，这里的优缺点在 <code>Symbol</code> 中已经分析了。</p>\n</li>\n<li>\n<p>常规的私有化方法是使用<strong>闭包</strong>，只对外开发非私有化的部分。下面这个例子挺好的，原网址： <a href=\"http://blog.csdn.net/dai_jing/article/details/47165691\">js 使用闭包封装数据</a></p>\n<pre class=\"prettyprint\"><code>var Student=(function(){  \n    var m_staticMaxAge = 120;&#x2F;&#x2F;定义一个私有的静态属性  \n    \n    function ageIsValid(age){ &#x2F;&#x2F;定义一个私有的静态方法  \n        if(age &gt; m_staticMaxAge){  \n            throw Error(&quot;the property age must be less than &quot;+m_staticMaxAge);  \n        }  \n    }  \n  \n    &#x2F;&#x2F;返回构造函数，设置一些属性  \n    return function (name,age) {  \n  \n        var m_name, m_age;&#x2F;&#x2F;把私有属性都放到这里定义  \n  \n        &#x2F;&#x2F;私有属性的 setter 和 getter 都放到这里  \n        this.setName = function (name) {  \n  \n            Student.nameIsValid(name);  \n            m_name = name;  \n        };  \n  \n        this.setAge = function (age) {  \n            ageIsValid(age);  \n            m_age = age;  \n        };  \n  \n        this.getName = function () {  \n            return m_name;  \n        };  \n  \n        this.getAge = function () {  \n            return m_age;  \n        };  \n  \n        this.setName(name);  \n        this.setAge(age);  \n    };  \n})();\n</code></pre></li>\n</ul>\n</div>",
    "title": "我来回答饿了么大前端的问题（1）",
    "last_reply_at": "2017-06-01T11:23:14.997Z",
    "good": true,
    "top": false,
    "reply_count": 20,
    "visit_count": 2195,
    "create_at": "2017-04-23T14:06:17.300Z",
    "author": {
      "loginname": "TalkWIthKeyboard",
      "avatar_url": "https://avatars0.githubusercontent.com/u/8086486?v=3&s=120"
    }
  }, {
    "id": "5927eea8d371b6372a8afe46",
    "author_id": "5926c7a99e32cc84569a7374",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>最简单的方法:\n\t\t…\n\t\t努力学习吧!\n超级简单:\n\t\t死记硬背!</p>\n</div>",
    "title": "关于Node学习的方法,帅的人都会进来!",
    "last_reply_at": "2017-06-01T11:10:29.346Z",
    "good": false,
    "top": false,
    "reply_count": 7,
    "visit_count": 446,
    "create_at": "2017-05-26T09:00:24.888Z",
    "author": {
      "loginname": "libaishunye",
      "avatar_url": "https://avatars0.githubusercontent.com/u/28948484?v=3&s=120"
    }
  }, {
    "id": "592fd77b1e7e75f60c1ad82a",
    "author_id": "59223ae1d371b6372a8afc0e",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p>Node 公开宣称的目标是 “旨在提供一种简单的构建可伸缩网络程序的方法”。当前的服务器程序有什么问题？我们来做个数学题。在 Java™ 和 PHP 这类语言中，每个连接都会生成一个新线程，每个新线程可能需要 2 MB 的配套内存。在一个拥有 8 GB RAM 的系统上，理论上最大的并发连接数量是 4,000 个用户。随着您的客户群的增长，如果希望您的 Web 应用程序支持更多用户，那么，您必须添加更多服务器。当然，这会增加服务器成本、流量成本和人工成本等成本。除这些成本上升外，还有一个潜在技术问题，即用户可能针对每个请求使用不同的服务器，因此，任何共享资源都必须在所有服务器之间共享。鉴于上述所有原因，整个 Web 应用程序架构（包括流量、处理器速度和内存速度）中的瓶颈是：服务器能够处理的并发连接的最大数量。\nNode 解决这个问题的方法是：更改连接到服务器的方式。每个连接发射一个在 Node 引擎的进程中运行的事件，而不是为每个连接生成一个新的 OS 线程（并为其分配一些配套内存）。Node 声称它绝不会死锁，因为它根本不允许使用锁，它不会直接阻塞 I/O 调用。Node 还宣称，运行它的服务器能支持数万个并发连接。\n现在您有了一个能处理数万个并发连接的程序，那么您能通过 Node 实际构建什么呢？如果您有一个 Web 应用程序需要处理这么多连接，那将是一件很 “恐怖” 的事！那是一种 “如果您有这个问题，那么它根本不是问题” 的问题。在回答上面的问题之前，我们先看看 Node 的工作原理以及它的设计运行方式。</p>\n</div>",
    "title": "Node 旨在解决什么问题？",
    "last_reply_at": "2017-06-01T11:07:16.179Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 132,
    "create_at": "2017-06-01T08:59:39.487Z",
    "author": {
      "loginname": "xiaoxiaoql",
      "avatar_url": "https://avatars2.githubusercontent.com/u/26704498?v=3&s=120"
    }
  }, {
    "id": "5870e9da04dcf9a706a745f0",
    "author_id": "4efc278525fa69ac6900000f",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><p><a href=\"https://eggjs.org/\">egg</a> 自9月份在宁JS正式宣布开源以来，一直在迭代改进。源代码是开放出来了，但是文档一直落后于代码进度。</p>\n<p><strong>开源不仅仅是代码，文档也是非常重要的部分。</strong></p>\n<p>为了让 egg 文档尽快完成第一个发布版本，egg 团队已经齐聚北京，陪伴着雾霾在集中讨论和分工开始编写着自高考以来最大的一次文字工作。</p>\n<p>在吸着雾霾写文档之余，我们也想尽快让对 egg 感兴趣的同学在第一时间看到最新鲜的文档，所以我们决定每天都会直播当天 review 通过的文档，会以回复的形式粘贴写来。</p>\n<p>当然，第一版文档并不会涵盖 egg 框架的方方面面，如果不足，欢迎大家敦促指正。</p>\n</div>",
    "title": "直播 egg 文档产生的过程",
    "last_reply_at": "2017-06-01T11:06:31.711Z",
    "good": true,
    "top": false,
    "reply_count": 92,
    "visit_count": 7449,
    "create_at": "2017-01-07T13:15:06.899Z",
    "author": {
      "loginname": "fengmk2",
      "avatar_url": "https://avatars3.githubusercontent.com/u/156269?v=3&s=120"
    }
  }, {
    "id": "5364dcde31a870830700b847",
    "author_id": "516ab23d6d3827730636c3fb",
    "content": "<div class=\"markdown-text\"><p>欢迎看原文：<a href=\"http://weizhifeng.net/how-to-publish-a-node-module.html\">http://weizhifeng.net/how-to-publish-a-node-module.html</a></p>\n<p>“学骑自行车最快的方式就是先骑上去”</p>\n<p>#安装node和npm</p>\n<p>安装node(注意：需要Python 2.6或2.7已经安装)</p>\n<pre class=\"prettyprint\"><code>$ wget http:&#x2F;&#x2F;nodejs.org&#x2F;dist&#x2F;v0.10.26&#x2F;node-v0.10.26.tar.gz\n$ tar -zxvf node-v0.10.26.tar.gz\n$ make &amp;&amp; make install \n</code></pre><p>成功安装node之后，<code>npm</code>(node package manager)已经包含在内了，不需要独立安装，可以执行一下<code>npm</code>检查是否安装好。</p>\n<pre class=\"prettyprint\"><code>$ npm \nUsage: npm &lt;command&gt;\n</code></pre><p>#创建repository</p>\n<p>接下来我们需要创建module所需的repository，默认你拥有一个github账号（如果没有自行解决），这个repository用来托管我们module的代码，并方便用户报告bug，最重要的是可以让其他开发者向module贡献代码，这也是乐趣所在。</p>\n<p>#初始化package.json</p>\n<p>接下来我们创建<code>package.json</code>文件，这个文件包含了module的所有信息，比如名称、版本、描述、依赖、作者、license等。笔者以自己的easy_mongo(注意：npm要求项目的名称必须为小写字母)项目为例，看如何创建<code>package.json</code>。</p>\n<p>首先创建我们module的目录</p>\n<pre class=\"prettyprint\"><code>$ mkdir easy_mongo &amp;&amp; cd easy_mongo\n</code></pre><p>之后执行<code>npm init</code>，系统会提示你输入所需的信息，不想输入的直接输入<code>Enter</code>可以跳过。</p>\n<pre class=\"prettyprint\"><code>$ npm init\n\nThis utility will walk you through creating a package.json file.\nIt only covers the most common items, and tries to guess sane defaults.\n\nSee &#96;npm help json&#96; for definitive documentation on these fields\nand exactly what they do.\n\nUse &#96;npm install &lt;pkg&gt; --save&#96; afterwards to install a package and\nsave it as a dependency in the package.json file.\n\nPress ^C at any time to quit.\nname: (node) easy_mongo\nversion: (0.0.0) 0.1.0\ndescription: An easy mongodb client for node.js based on native mongodb driver.\nentry point: (index.js) \ntest command: make test\ngit repository: https:&#x2F;&#x2F;github.com&#x2F;JeremyWei&#x2F;easy_mongo.git\nkeywords: Mongodb node easy \nauthor: JeremyWei\nlicense: (BSD-2-Clause) MIT\n</code></pre><p>输入完成之后，系统会要你确认文件的内容是否有误，如果没有问题直接输入<code>yes</code>，那么<code>package.json</code>就创建好了。</p>\n<pre class=\"prettyprint\"><code>About to write to &#x2F;Users&#x2F;weizhifeng&#x2F;dev&#x2F;node&#x2F;package.json:\n\n{\n  &quot;name&quot;: &quot;easy_mongo&quot;,\n  &quot;version&quot;: &quot;0.1.0&quot;,\n  &quot;description&quot;: &quot;An easy mongodb client for node.js based on native mongodb driver.&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;directories&quot;: {\n    &quot;example&quot;: &quot;examples&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;test&quot;: &quot;make test&quot;\n  },\n  &quot;repository&quot;: {\n    &quot;type&quot;: &quot;git&quot;,\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;JeremyWei&#x2F;easy_mongo.git&quot;\n  },\n  &quot;keywords&quot;: [\n    &quot;Mongodb&quot;,\n    &quot;node&quot;,\n    &quot;easy&quot;\n  ],\n  &quot;author&quot;: &quot;JeremyWei&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;bugs&quot;: {\n    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;JeremyWei&#x2F;easy_mongo&#x2F;issues&quot;\n  }\n}\n\nIs this ok? (yes) \n</code></pre><p><code>npm init</code>创建的<code>package.json</code>文件只包含了基本的信息，我们还需要加入对其他module的依赖关系：</p>\n<pre class=\"prettyprint\"><code>&quot;dependencies&quot;: {\n\t&quot;mocha&quot; : &quot;1.18.2&quot;,\n\t&quot;should&quot; : &quot;3.3.0&quot;,\n\t&quot;mongodb&quot; : &quot;1.3.19&quot;\n}\n</code></pre><p>#项目结构</p>\n<p><code>package.json</code>文件只是第一步，要完成一个module，我们还需要许多其他文件，整体的文件夹结构如下：</p>\n<pre class=\"prettyprint\"><code>easy_mongo\n├─┬ lib\n│ └── easy_mongo.js\n├─┬ test\n│ └── all.js\n├── .gitignore\n├── .npmignore\n├── .travis.yml\n├── index.js\n├── LICENSE\n├── makefile\n├── package.json\n├── README.md\n</code></pre><p>这些文件的作用是：</p>\n<ul>\n<li>lib目录下存放业务逻辑文件</li>\n<li>test目录下存放单元测试用例</li>\n<li>.npmignore记录哪些文件不需要被发布到npmjs.org</li>\n<li>.travis.yml是持续集成服务<a href=\"https://travis-ci.org/\">travis</a>的描述文件</li>\n<li>index.js是入口文件</li>\n<li>makefile方便我们用<code>make test</code>进行测试</li>\n<li><code>README.md</code>是此module的描述和使用方法</li>\n</ul>\n<p>#持续集成</p>\n<p>开源项目多如牛毛，从中找出靠谱的项目需要花费一定的精力，开发者都会对持续更新，并且经过测试（很多公司采用）的项目更加的信赖，对于刚上线并且用户数量很少的项目开发者都会有个疑虑：这项目靠谱吗？所以你需要对自己的项目打上一个标识：老子的项目靠谱。如何做？持续集成。</p>\n<p>目前Github已经整合了持续集成服务<a href=\"https://travis-ci.org/\">travis</a>，我们只需要在项目中添加<code>.travis.yml</code>文件，在下一次push之后，travis就会定时执行<code>npm test</code>来测试你的项目，并且会在测试失败的时候通知到你，你也可以把项目当前的状态显示在<code>README.md</code>中，让人一目了然，比如：</p>\n<p><a href=\"https://travis-ci.org/JeremyWei/easy_mongo\"><img src=\"https://travis-ci.org/JeremyWei/easy_mongo.svg?branch=master\" alt=\"Build Status\"></a></p>\n<p><code>.travis.yml</code>是一个YAML文件，关于node.js相关的配置见<a href=\"http://docs.travis-ci.com/user/languages/javascript-with-nodejs/\">这里</a>，例子如下：</p>\n<pre class=\"prettyprint\"><code>language: node_js\nnode_js:\n   - &quot;0.10&quot;\n   - &quot;0.8&quot;\n   - &quot;0.6&quot;\t \nservices:\n\t- mongodb\n</code></pre><p>这个例子的是让travis在node.js的0.6.x，0.8.x，0.10.x三个版本下对项目进行测试，并且需要mongodb的服务。</p>\n<p>#发布</p>\n<p>完成了上面的步骤之后，我们接下来要在www.npmjs.org注册一个账号，这个账号会被添加到npm本地的配置中，用来发布module用。</p>\n<pre class=\"prettyprint\"><code>$ npm adduser\t\nUsername: your name\nPassword: your password\nEmail: yourmail[@gmail](&#x2F;user&#x2F;gmail).com\n</code></pre><p>如果出现以下错误，可能是你的npm版本太低，通过<code>sudo npm install -g npm</code>升级一下。</p>\n<pre class=\"prettyprint\"><code>npm WARN adduser Incorrect username or password\nnpm WARN adduser You can reset your account by visiting:\nnpm WARN adduser \nnpm WARN adduser     http:&#x2F;&#x2F;admin.npmjs.org&#x2F;reset\nnpm WARN adduser \nnpm ERR! Error: forbidden may not mix password_sha and pbkdf2\nnpm ERR! You may need to upgrade your version of npm:\nnpm ERR!   npm install npm -g\nnpm ERR! Note that this may need to be run as root&#x2F;admin (sudo, etc.)\n</code></pre><p>成功之后，npm会把认证信息存储在<code>~/.npmrc</code>中，并且可以通过以下命令查看npm当前使用的用户：</p>\n<pre class=\"prettyprint\"><code>$ npm whoami \n</code></pre><p>以上完成之后，我们终于可以发布自己的module了：</p>\n<pre class=\"prettyprint\"><code>$ npm publish --tag 0.1.0\nnpm http PUT https:&#x2F;&#x2F;registry.npmjs.org&#x2F;easy_mongo\nnpm http 201 https:&#x2F;&#x2F;registry.npmjs.org&#x2F;easy_mongo\n+ easy_mongo[@0](&#x2F;user&#x2F;0).1.0\n</code></pre><p>npm社区版本号规则采用的是<a href=\"http://semver.org/\">semver</a>(语义化版本)，主要规则如下：</p>\n<pre class=\"prettyprint\"><code>版本格式：主版号.次版号.修订号，版号递增规则如下：\n\t主版号：当你做了不相容的 API 修改，\n\t次版号：当你做了向下相容的功能性新增，\n\t修订号：当你做了向下相容的问题修正。\n\t先行版号及版本编译资讯可以加到「主版号.次版号.修订号」的后面，作为延伸。\n</code></pre><p>至此，<a href=\"http://xn--modulenpmjs-ox9qh5bu8znsbc2iir8c8ia629dra95w545w.org\">我们已经成功把module发布到了npmjs.org</a>，是不是很简单，快动手把自己的module也贡献出来吧。</p>\n<p>Have fun :)</p>\n<p>#参考</p>\n<ul>\n<li><a href=\"https://github.com/npm/npm\">https://github.com/npm/npm</a></li>\n<li><a href=\"https://www.npmjs.org/doc/api/npm-publish.html\">https://www.npmjs.org/doc/api/npm-publish.html</a></li>\n<li><a href=\"https://www.npmjs.org/doc/cli/npm-adduser.html\">https://www.npmjs.org/doc/cli/npm-adduser.html</a></li>\n<li><a href=\"http://docs.travis-ci.com/user/languages/javascript-with-nodejs/\">http://docs.travis-ci.com/user/languages/javascript-with-nodejs/</a></li>\n<li><a href=\"http://docs.travis-ci.com/user/database-setup/\">http://docs.travis-ci.com/user/database-setup/</a></li>\n<li><a href=\"http://semver.org/\">http://semver.org/</a></li>\n</ul>\n</div>",
    "title": "如何发布Node模块到NPM社区",
    "last_reply_at": "2017-06-01T10:57:58.463Z",
    "good": true,
    "top": false,
    "reply_count": 11,
    "visit_count": 26170,
    "create_at": "2014-05-03T12:11:10.645Z",
    "author": {
      "loginname": "jeremywei",
      "avatar_url": "//gravatar.com/avatar/3cacbd11f07e5e4978318b294b95ccaf?size=48"
    }
  }, {
    "id": "592f7da6855efbac2cf7a544",
    "author_id": "52648cfa9df724eb6d3af9ad",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\\n\"><code>async function a (cb) {\n\tawait dosomething();\n\tcb();\n}\n\\n&#96;&#96;&#96;\n\n上面代码里面，如果dosomething卡住了，一直不返回，这个时候下面的cb就一直不会执行，这样就卡住了，有什么办法可以解决这个问题？\n\n有遇到过这种问题的朋友吗？有经验的话请不吝赐教，谢谢！</code></pre></div>",
    "title": "async await一直等待的问题",
    "last_reply_at": "2017-06-01T10:35:37.634Z",
    "good": false,
    "top": false,
    "reply_count": 6,
    "visit_count": 221,
    "create_at": "2017-06-01T02:36:22.943Z",
    "author": {
      "loginname": "wuzhizhemu",
      "avatar_url": "//gravatar.com/avatar/0c7abd42809fa9721e7e1c594c14ab79?size=48"
    }
  }, {
    "id": "592fece503dba3510d8a62a5",
    "author_id": "58dc7cb3b3e60b982d089d1d",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>test</p>\n</div>",
    "title": "这是一个测试的主题",
    "last_reply_at": "2017-06-01T10:31:01.343Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 55,
    "create_at": "2017-06-01T10:31:01.343Z",
    "author": {
      "loginname": "weihf",
      "avatar_url": "https://avatars0.githubusercontent.com/u/15108936?v=3&s=120"
    }
  }, {
    "id": "592e7397d371b6372a8aff4f",
    "author_id": "5124922fdf9e9fcc588efb2f",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>location / {\nproxy_pass    <a href=\"http://127.0.0.1:3000\">http://127.0.0.1:3000</a>;\nproxy_redirect default ;\n}</p>\n</div>",
    "title": "nginx 反向代理至 http://127.0.0.1:3000  静态资源404  咋整 ？",
    "last_reply_at": "2017-06-01T09:14:31.899Z",
    "good": false,
    "top": false,
    "reply_count": 3,
    "visit_count": 256,
    "create_at": "2017-05-31T07:41:11.189Z",
    "author": {
      "loginname": "allce231",
      "avatar_url": "//gravatar.com/avatar/e86b0eaaf7c6aeb101d81321c846553e?size=48"
    }
  }, {
    "id": "592fdaed1e7e75f60c1ad82d",
    "author_id": "526a274f9df724eb6dfb95f3",
    "tab": "share",
    "content": "<div class=\"markdown-text\"><h1>唠叨</h1>\n<p>最近公司在开发一个社交管理后台，看一遍线框图后发现需要富文本编辑器我便找会上两年开发的<a href=\"https://github.com/lpreterite/vue-tinymce\">vue-tinymce</a>组件，可惜的是组件支持还是vue1，所以这个组件需要升级支持vue2。然后有朋友问我为何不用现有的？因为看一圈回来发觉比较不靠谱的啊，全部都需要赋予id值（明明可以内部处理的为何要外部传入？），实在看不下去结果还是完善自己写的这个没多少收藏的库吧:)</p>\n<h1>关于 vue-tinymce</h1>\n<p><a href=\"https://github.com/lpreterite/vue-tinymce\">vue-tinymce</a> 只是基于tinymce封装的vue组件，让用vue的同学能快速使用tinymce富文本编辑器。</p>\n<h2>过程</h2>\n<h3>从tinymce开始</h3>\n<p>接下来分享一些开发过程中的一些问题，首先要学会<strong>初次化</strong>，我们先来看看tinymce的官方例子：</p>\n<pre class=\"prettyprint\"><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;script src=&quot;https:&#x2F;&#x2F;cloud.tinymce.com&#x2F;stable&#x2F;tinymce.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n  &lt;textarea&gt;Next, get a free TinyMCE Cloud API key!&lt;&#x2F;textarea&gt;\n  &lt;script&gt;\n    tinymce.init({\n        selector:&#x27;textarea&#x27;\n        &#x2F;&#x2F;or\n        &#x2F;&#x2F; target: document.querySelector(&#x27;textarea&#x27;)\n    });\n  &lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><p>能看出tinymce需要引入全局\b才能使用，就没其他方式了？于是我找了一下<a href=\"https://www.npmjs.com/search?q=tinymce\">npmjs.org</a>有的有的，可以用import引入。</p>\n<p>于是不用想立马写个例子试试</p>\n<pre class=\"prettyprint\"><code># index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n  &lt;textarea&gt;Next, get a free TinyMCE Cloud API key!&lt;&#x2F;textarea&gt;\n  &lt;script src=&quot;dist&#x2F;main.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n\n# main.js\nimport tinymce form &#x27;tinymce&#x27;;\ntinymce.init({\n    selector:&#x27;textarea&#x27;\n    &#x2F;&#x2F;or\n    &#x2F;&#x2F; target: document.querySelector(&#x27;textarea&#x27;)\n});\n</code></pre><p>结果发现tinymce是加载出来了，但是样式和图标那些没了…好吧不折腾还是直接引入吧目前来说问题不大。（看看其他库都是直接引入，我不折腾算是对了）</p>\n<p>好了，第一步完成了，接下来第二步是<strong>获得/设定富文本内容</strong>，来看看以下代码：</p>\n<pre class=\"prettyprint\"><code># main.js\ntinymce.init({\n    selector: &#x27;textarea&#x27;,\n    &#x2F;&#x2F; 获得editor，当有多个textarea实例时会多次调用setup\n    setup: (editor)=&gt; {\n        &#x2F;&#x2F; 初次化编辑器\n        editor.on(&#x27;init&#x27;, ()=&gt;{\n            &#x2F;&#x2F; 设置默认值\n            editor.setContent(&#x27;&lt;p&gt;Default Value!&lt;&#x2F;p&gt;&#x27;);\n            &#x2F;&#x2F; 注册事件\n            editor.on(&#x27;input change undo redo&#x27;, ()=&gt;{\n                &#x2F;&#x2F; 获得编辑结果\n                console.log(editor.getContent());\n            });\n        });\n    }\n})\n</code></pre><p>上面这段是已总结怎样获得或设置富文本内容，tinymce知道怎样用就能开始写vue组件。</p>\n<h3>需要怎样的vue组件</h3>\n<p>作为组件配置当然可以自己设定的固需要<code>setting</code>的传入，可能也需要在初次化动手再自定义一些功能所以加上<code>setup</code>，再来是获得<code>editor</code>进行处理一些富文本数据。起步代码是这样的：</p>\n<pre class=\"prettyprint\"><code>&lt;template&gt;\n    &lt;textarea :id=&quot;id&quot;&gt;&lt;&#x2F;textarea&gt;\n&lt;&#x2F;template&gt;\n&lt;script&gt;\nexport default {\n    props: [&#x27;setting&#x27;,&#x27;setup&#x27;, &#x27;value&#x27;],\n    data(){ return {id:&#x27;tinymce&#x27;, editor:null}; }\n    mounted(){\n        const setting = {\n            ...this.setting,\n            {\n                selector: &#96;#${this.id}&#96;,\n                setup: (editor)=&gt; {\n                    this.setup(editor);\n                    this.editor = editor;\n                    editor.on(&#x27;init&#x27;, ()=&gt;{\n                        editor.setContent(this.value);\n                        editor.on(&#x27;input change undo redo&#x27;, ()=&gt;{\n                            this.value = editor.getContent();\n                        });\n                    });\n                }\n            }\n        };\n        tinymce.init(setting);\n    },\n    beforeDestroy: function(){\n        tinymce.remove(this.id);\n    }\n}\n&lt;&#x2F;script&gt;\n</code></pre><h4>自管理id</h4>\n<p>对比其他vue-tinymce组件都要传入id我感到很不解，因为根本没这个必要，所以接下来先解决id自管理问题。</p>\n<pre class=\"prettyprint\"><code>export default {\n    ...\n    &#x2F;&#x2F; 这里我用render写在template绑定:id一样可以\n    render(createElement){\n        return createElement(&#x27;textarea&#x27;, {\n            attrs: {\n                id: this.id\n            }\n        });\n    },\n    data(){\n        return {\n            &#x2F;&#x2F;生成id\n            id: &#x27;vue-tinymce-&#x27;+Date.now(),\n        }\n    }\n    ...\n}\n</code></pre><h4>支持v-model双向绑定</h4>\n<p>这个简单，只要传入字段(<code>props</code>)包含<code>value</code>，使用<code>v-model</code>就能从<code>value</code>获得绑定数据，然后当富文本编辑器数据跟新时使用<code>$emit('input', value)</code>方法便能通知变化跟新value。</p>\n<pre class=\"prettyprint\"><code>export default {\n    ...\n    watchs:{\n        value(val){\n            &#x2F;&#x2F; 当传入值变化时跟新富文本内容\n            tinymce.get(this.id).setContent(val);\n        }\n    },\n    mounted(){\n        const setting = {\n            ...this.setting,\n            {\n                selector: &#96;#${this.id}&#96;,\n                setup: (editor)=&gt; {\n                    this.setup(editor);\n                    this.editor = editor;\n                    editor.on(&#x27;init&#x27;, ()=&gt;{\n                        editor.setContent(this.value);\n                        editor.on(&#x27;input change undo redo&#x27;, ()=&gt;{\n                            this.$emit(&#x27;input&#x27;, editor.getContent());\n                        });\n                    });\n                }\n            }\n        };\n        tinymce.init(setting);\n    }\n    ...\n}\n</code></pre><p>到这里将近完成了，可惜\b这次问题静静地出现了：输入一个字光标就刷到最前面。接下来得解决这问题，思路我猜应该是editor的input事件触发<code>$emit('input')</code>然后进入watch调用了<code>editor.setContent()</code>方法后导致光标更新，这里解决办法是当前编辑不让触发<code>editor.seContent()</code>就不会导致光标更新（当然还有其他方法，比如记录光标位置）。</p>\n<pre class=\"prettyprint\"><code>const INIT = 0;\nconst INPUT = 1;\nconst CHANGED = 2;\n\nexport default {\n    ...\n    watchs:{\n        value(val){\n            &#x2F;&#x2F; 只在外部引起变化时才跟新编辑器\n            if(this.status === CHANGED || selt.status === INIT) return this.status = INPUT;\n            tinymce.get(this.id).setContent(val);\n        }\n    },\n    mounted(){\n        const setting = {\n            ...this.setting,\n            {\n                selector: &#96;#${this.id}&#96;,\n                setup: (editor)=&gt; {\n                    this.setup(editor);\n                    this.editor = editor;\n                    editor.on(&#x27;init&#x27;, ()=&gt;{\n                        editor.setContent(this.value);\n                        editor.on(&#x27;input change undo redo&#x27;, ()=&gt;{\n                            &#x2F;&#x2F; 只在用户输入导致事件相应时才更新value数据\n                            if(this.status === INPUT || this.status === INIT) return this.status = CHANGED;\n                            this.$emit(&#x27;input&#x27;, editor.getContent());\n                        });\n                    });\n                }\n            }\n        };\n        tinymce.init(setting);\n    }\n    ...\n}\n</code></pre><p>当value从外部更新时才更新编辑器内容，编辑器触发的内容更新并不需要绕一圈回来再更新编辑器，这样便能解决光标问题。</p>\n<h2>结果</h2>\n<p>就在这<a href=\"https://github.com/lpreterite/vue-tinymce\">vue-tinymce</a>，一些细节不补充，建议看源码。以下是使用方法：</p>\n<h3>安装</h3>\n<pre class=\"prettyprint\"><code>$ npm i -D lpreterite&#x2F;vue-tinymce\n</code></pre><h3>使用</h3>\n<pre class=\"prettyprint\"><code># index.html\n&lt;div id=&quot;app&quot;&gt;\n  &lt;vue-tinymce\n    ref=&quot;tinymce&quot;\n    v-model=&quot;content&quot;\n    :setting=&quot;setting&quot;&gt;\n  &lt;&#x2F;vue-tinymce&gt;\n&lt;&#x2F;div&gt;\n&lt;!-- in last --&gt;\n&lt;script src=&quot;node_modules&#x2F;tinymce&#x2F;tinymce.min.js&quot;&gt;&lt;&#x2F;script&gt;\n\n# main.js\nimport Vue from &#x27;vue&#x27;;\nimport VueTinymce from &#x27;vue-tinymce.vue&#x27;;\n\nnew Vue({\n    el: &#x27;#app&#x27;,\n    data: function(){\n        return {\n            content: &#x27;&lt;p&gt;html content&lt;&#x2F;p&gt;&#x27;,\n            setting: {\n                height: 200,\n                language_url: &quot;langs&#x2F;zh_CN.js&quot;,\n                block_formats: &quot;Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;&quot;\n            }\n        }\n    }\n})\n</code></pre><p>目录结构</p>\n<pre class=\"prettyprint\"><code>dist&#x2F;\n- index.html\n- main.js\n- lang&#x2F;\n    -zh_CN.js\nnode_modules&#x2F;\n- tinymce&#x2F;\n</code></pre><h1>遇到的问题</h1>\n<p>刚开始想写vue2组件我跑了一圈github也没发现比较好的例子，构建工具及配置直接能用的并没有，参考的倒是找到一些。webpack配置算是个麻烦事，想尽量简化工作就得动动脑子。</p>\n<p><a href=\"https://github.com/vuejs/vue-cli\">vue-cli</a>是个好东西，能帮你快速创建项目，如想创建vue的单页项目可以这样使用：</p>\n<pre class=\"prettyprint\"><code>$ vue init webpack-simple my-product\n</code></pre><p>可是没见到有快速创建vue组件的项目，所以这里我写了一个<a href=\"https://github.com/lpreterite/vue-component-project\">lpreterite/vue-component-project</a>提供给大家使用。</p>\n<p>使用方法：</p>\n<pre class=\"prettyprint\"><code>$ vue init lpreterite&#x2F;vue-component-project my-vue-component\n\n</code></pre><p>一路回车之后会提示</p>\n<pre class=\"prettyprint\"><code>   vue-cli · Generated &quot;my-vue-component&quot;.\n\n   To get started:\n   \n     cd my-vue-component\n     npm install\n     npm run dev \n     npm run hot.\n</code></pre><p>项目就这样创建好来👌，剩下交给你们发挥。</p>\n<p>这遍文章算是把手上这个大项目的副产品吧 :) 。希望日后有点时间继续分享其他在经验及一些大项目下的组件，欢迎评论和PR！</p>\n<blockquote>\n<p><a href=\"https://segmentfault.com/a/1190000009621081\">前端手札——vue组件vue-tinymce开发经验分享</a></p>\n</blockquote>\n</div>",
    "title": "前端手札——vue组件vue-tinymce开发经验分享",
    "last_reply_at": "2017-06-01T09:14:21.118Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 92,
    "create_at": "2017-06-01T09:14:21.118Z",
    "author": {
      "loginname": "lpreterite",
      "avatar_url": "//gravatar.com/avatar/c395c199d63e45d334b926a1b7b4774e?size=48"
    }
  }, {
    "id": "590a9993bbaf2f3f569be519",
    "author_id": "590a9778782dbc4b183ed037",
    "tab": "job",
    "content": "<div class=\"markdown-text\"><p><a href=\"http://www.GeTui.com\">http://www.GeTui.com</a>\n<strong>职位诱惑：</strong>\n带薪年假，扁平化管理，无限量美食，餐补。全年16-18薪，一年2次调薪。\n<strong>职位描述：</strong>\n1.熟练使用JavaScript、NodeJS，并掌握至少一门后端语言(python，java, php等)。\n2.良好的CS修养（操作系统和算法知识等）。\n3.代码质量精益求精，注重性能，并且具备良好的自我管理和自我驱动能力，能够独立完成开发任务。\n4.对服务端框架的机制，框架的设计模式，数据库的优化，服务器的负载均衡设计，并发时服务器的优化，服务器的压力测试以及功能模块的单元测试有了解的优先。\n5.熟悉在Linux/Mac下的工作环境，熟悉 TCP/UDP/HTTP 等网络协议。\n6.熟练使用git进行分支管理、冲突合并。\n<strong>工作地址</strong>：\n杭州 - 西湖区 - 古墩路 - 西斗门路福地创业园\n<strong>联系人</strong>：\nMonica<br>\n<strong>联系方式</strong>：\n15012684571，qq：2697055256</p>\n</div>",
    "title": "（杭州西湖区）互联网D轮公司（个推）高薪招聘Node.js ，薪资20-30w，2年以上经验~~",
    "last_reply_at": "2017-06-01T09:10:11.915Z",
    "good": false,
    "top": false,
    "reply_count": 18,
    "visit_count": 595,
    "create_at": "2017-05-04T03:01:39.980Z",
    "author": {
      "loginname": "monicading",
      "avatar_url": "https://avatars3.githubusercontent.com/u/11417588?v=3&s=120"
    }
  }, {
    "id": "592fd97a03dba3510d8a6299",
    "author_id": "5926df21ba8670562a40f4fd",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>阿斯顿发生的范德萨范德萨范德萨发生的第三方第三方</p>\n</div>",
    "title": "测试一下,大力开发了快递费",
    "last_reply_at": "2017-06-01T09:08:10.512Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 58,
    "create_at": "2017-06-01T09:08:10.512Z",
    "author": {
      "loginname": "xiaowei1998",
      "avatar_url": "https://avatars3.githubusercontent.com/u/28948458?v=3&s=120"
    }
  }, {
    "id": "592fcecce018d6750dbfa108",
    "author_id": "585b81a6347bab4d645b337a",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><p>好的</p>\n</div>",
    "title": "客户端测试",
    "last_reply_at": "2017-06-01T08:22:36.695Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 62,
    "create_at": "2017-06-01T08:22:36.695Z",
    "author": {
      "loginname": "xdlnode",
      "avatar_url": "https://avatars3.githubusercontent.com/u/24712144?v=3&s=120"
    }
  }, {
    "id": "591bc04c9e32cc84569a7064",
    "author_id": "57a362237a922d6f358cd209",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>大神指点一下我把</p>\n</div>",
    "title": "想换工作，会前端会nodejs会shell会数据库会点运维，但是不知道怎么写简历",
    "last_reply_at": "2017-06-01T08:02:26.278Z",
    "good": false,
    "top": false,
    "reply_count": 6,
    "visit_count": 704,
    "create_at": "2017-05-17T03:15:24.087Z",
    "author": {
      "loginname": "Rock-1",
      "avatar_url": "https://avatars3.githubusercontent.com/u/13210424?v=3&s=120"
    }
  }, {
    "id": "5356941713bdad651a11389c",
    "author_id": "4fd7eecb3169f15e120ac56f",
    "content": "<div class=\"markdown-text\"><p>1、Node.js + MySQL 数据库 大家用的都是什么 ORM 框架？本来准备用 MySQL 原生查询的，但是返回的结果集封装起来太麻烦，还是想用一下 ORM。\n2、<code>npm install orm</code> 失败，提示 <code>npm ERR! not found: git</code>， 有人遇到过吗？求解答</p>\n</div>",
    "title": "Node.js + MySQL 数据库 大家用的都是什么 ORM 框架？",
    "last_reply_at": "2017-06-01T07:48:57.289Z",
    "good": false,
    "top": false,
    "reply_count": 15,
    "visit_count": 36247,
    "create_at": "2014-04-22T16:08:55.864Z",
    "author": {
      "loginname": "sinple",
      "avatar_url": "//gravatar.com/avatar/882374eba72a496c3de815b03190dba6?size=48"
    }
  }, {
    "id": "592fc0d803dba3510d8a628b",
    "author_id": "57de06085710e2ed658d6bd4",
    "tab": "ask",
    "content": "<div class=\"markdown-text\"><p>fetch 代码如下</p>\n<pre class=\"prettyprint language-js\\n\"><code>import fetch from &#x27;dva&#x2F;fetch&#x27;;\n\n&#x2F;&#x2F; 将对象拼接成 key1=val1&amp;key2=val2&amp;key3=val3 的字符串形式\n  function obj2params(obj) {\n    var result = &#x27;&#x27;;\n    var item;\n   \n    for (item in obj) {\n        result += &#x27;&amp;&#x27; + item + &#x27;=&#x27; + encodeURIComponent(obj[item]);\n    }\n    if (result) {\n        result = result.slice(1);\n    }\n\n    return result;\n}\n\n&#x2F;&#x2F; 发送 post 请求\nexport function post(url, paramsObj,token) {\n    var result = fetch(url, {\n        method: &#x27;POST&#x27;,\n        headers: {\n            &#x27;Accept&#x27;: &#x27;application&#x2F;json, text&#x2F;plain, *&#x2F;*&#x27;,\n            &#x27;Content-Type&#x27;: &#x27;application&#x2F;x-www-form-urlencoded&#x27;,\n            &#x27;token&#x27;:token\n        },\n        body: obj2params(paramsObj)\n    });\n\n    return result;\n}\n\nreact发送请求代码如下：\n\n   this.props.form.validateFields((err, values) =&gt; {\n            if (!err) {\n                var result = post(conf.loginPath + &quot;username=&quot; + values.userName +\n                    &#x27;&amp;password=&#x27; + values.password, {\n                        username: values.userName,\n                        password: values.password\n                    }, token\n                );\n                console.log(result)\n                result.then(res =&gt; {\n                    return res.json();\n                }).then(json =&gt; {\n                    console.log(json)\n                    if (json.username) {\n                        &#x2F;&#x2F;储存用户信息 \n                        localStorage.setItem(&#x27;username&#x27;, json.username);\n                        localStorage.setItem(&#x27;power&#x27;, json.power)\n                        localStorage.setItem(&#x27;id&#x27;, json.id)\n                        localStorage.setItem(&#x27;token&#x27;, json.token)\n                        hashHistory.push(&#x27;&#x2F;firstPage&#x27;)\n                    } else {\n                        this.setState({\n                            showWarning: true\n                        })\n                    }\n                }).catch(function(e){\n                    console.log(e)\n                })\n            }\n\nkoa2 后台代码如下：\n＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝》加入此段代码报错\nrouter.use(async (ctx, next) =&gt; {\n    let path = ctx.request.path;\n    if (&#x27;&#x2F;users&#x2F;login&#x27;===path) {\n        next();\n    } else {\n        let _token = ctx.request.headers.token || &#x27;&#x27;;\n        &#x2F;&#x2F;去数据库查询token\n        let token_query = await TokenModel.queryToken(_token);\n        let times = token_query.cTime;\n        if (token_query !== &#x27;&#x27; || token_query !== null) {\n            let exp = parseInt((new Date().getTime() - times) &#x2F; 1000 &#x2F; 60);\n            if (exp &gt; 5) {\n                &#x2F;&#x2F;从数据库删除记录\n                await TokenModel.deleteToken(token_query._id)\n                return ctx.body = { msg: &#x27;timeOut&#x27; }\n            } else {\n                next();\n            }\n        }\n    }\n})\n\n＝＝＝＝＝＝》当加入以上代码的时候报错\n&#x2F;&#x2F; 登录页面\nrouter.post(&#x27;&#x2F;users&#x2F;login&#x27;, async (ctx, next) =&gt; {\n    let username = ctx.request.body.username || &#x27;&#x27;;\n    let pwd = ctx.request.body.password || &#x27;&#x27;;\n    let _token = ctx.request.headers.token || &#x27;&#x27;;\n    console.log(&quot;username======&quot;+username);\n    console.log(&quot;pwd=======&quot;+pwd)\n    console.log(&quot;_token=======&quot;+_token)\n    let password = crypto.createHash(&#x27;md5&#x27;).update(pwd).digest(&#x27;hex&#x27;);\n    if (username === &#x27;&#x27; || password === &#x27;&#x27;) {\n        return;\n    }\n    &#x2F;&#x2F;first in\n    if (_token) {\n        let user = await UserModel.check_password(username, password);\n        console.log(user)\n        if (user === null) {\n            return ctx.response.body = { user: &#x27;null&#x27; };\n        }\n        let token = jwt.sign({\n            exp: Math.floor(Date.now() &#x2F; 1000) + (60 * 60),\n            data: &#x27;foobar&#x27;\n        }, username);\n        &#x2F;&#x2F;把token存入数据库\n        let token_result = await TokenModel.createToken(token, user._id);\n        return ctx.response.body = {\n             username: username,\n             power: user.power,\n             token: token,\n             id: user._id\n        };\n    }\n});\n\\n&#96;&#96;&#96;\n\n最后前端报错如下：\nPOST http:&#x2F;&#x2F;localhost:3000&#x2F;users&#x2F;login?username=admin&amp;password=111111 404 (Not Found)\nlogin.js:72  SyntaxError: Unexpected token N in JSON at position 0\n\n希望各位大神不吝赐教，不胜感激！！！！！！！！</code></pre></div>",
    "title": "请大神救急，在线等，关于fetch发送亲求报错问题！",
    "last_reply_at": "2017-06-01T07:39:14.752Z",
    "good": false,
    "top": false,
    "reply_count": 1,
    "visit_count": 86,
    "create_at": "2017-06-01T07:23:04.292Z",
    "author": {
      "loginname": "duzitengg",
      "avatar_url": "https://avatars1.githubusercontent.com/u/21256522?v=3&s=120"
    }
  }, {
    "id": "592fc37d1e7e75f60c1ad81d",
    "author_id": "50dcf518a7e6c6171a6db63f",
    "tab": "dev",
    "content": "<div class=\"markdown-text\"><h2>install</h2>\n<p>安装</p>\n<pre class=\"prettyprint language- bash\"><code>&gt; npm install typescript -g\n&gt; tsc -v\nVersion 2.3.2\n</code></pre><p>初始化, 生成tsconfig.json</p>\n<pre class=\"prettyprint language- bash\"><code>&gt; tsc --init\n</code></pre><h2>compiling and running</h2>\n<p>新建文件upAndRunning.ts</p>\n<pre class=\"prettyprint language- typescript\"><code>let foo: string = &quot;hello&quot;;\nconsole.log(foo);\n</code></pre><p>编译</p>\n<pre class=\"prettyprint language- bash\"><code>&gt; tsc upAndRunning.ts\n</code></pre><p>生成文件upAndRnnning.js</p>\n<pre class=\"prettyprint language- javascript\"><code>var foo = &quot;hello&quot;;\nconsole.log(foo);\n</code></pre><p>运行upAndRnnning.js</p>\n<pre class=\"prettyprint language- bash\"><code>&gt; node upAndRnnning.js\n</code></pre><h2>强类型</h2>\n<p>如果我们给foo赋值123</p>\n<pre class=\"prettyprint language- typescript\"><code>foo = 123;\n</code></pre><p>再编译</p>\n<pre class=\"prettyprint language- bash\"><code>&gt; tsc upAndRunning.ts\nupAndRunning.ts(4,1): error TS2322: Type &#x27;123&#x27; is not assignable to type &#x27;string&#x27;.\n</code></pre><h2>JavaScript 和 TypeScript定义</h2>\n<p>TypeScript里使用现成的JavaScript代码  <code>.d.ts</code>\n<a href=\"https://www.npmjs.com/~types\">types</a></p>\n<pre class=\"prettyprint language- typescript\"><code>import * as Util from &quot;util&quot;;\nconsole.log(util.format(&quot;Hello %s, world!&quot;, &quot;king&quot;));\n</code></pre><pre class=\"prettyprint language- bash\"><code>&gt; tsc upAndRunning.ts\nupAndRunning.ts(4,23): error TS2307: Cannot find module &#x27;util&#x27;.\n</code></pre><p>安装<a href=\"/user/types\">@types</a>/node</p>\n<pre class=\"prettyprint language- bash\"><code>&gt; npm install [@types](&#x2F;user&#x2F;types)&#x2F;node --save-dev\n&gt; tsc upAndRunning.ts\n&gt; node upAndRunning.js\n</code></pre><h2>封装</h2>\n<p>面向对象程序的最基本的一个原则就是封装, 这能力将定义数据和对数据一系列操作的功能定义到单一的组件当中. 大多数编程语言为了实现此目提出了类的概念，提供了一种为数据和相关功能定义模板的方式。</p>\n<pre class=\"prettyprint language- typescript\"><code>class MyClass { \n    add(x, y) { \n        return x + y; \n    } \n}\nvar classInstance = new MyClass(); \nvar result = classInstance.add(1,2); \nconsole.log(&#96;add(1,2) returns ${result}&#96;);\n</code></pre><h2>public 和 private</h2>\n<p>访问限制</p>\n<pre class=\"prettyprint language- typescript\"><code>class CountClass { \n    private _count: number; \n    constructor() { \n        this._count = 0; \n    } \n    countUp() { \n        this._count ++; \n    } \n    getCount() { \n        return this._count; \n    } \n} \nvar countInstance = new CountClass() ; \ncountInstance._count = 17;\n</code></pre><pre class=\"prettyprint language- bash\"><code>&gt; tsc upAndRunning.ts \nupAndRunning.ts(14,15): error TS2341: Property &#x27;_count&#x27; is private and only accessible within class &#x27;CountClass&#x27;.\n</code></pre><blockquote>\n<p>访问限制只是编译时的一种特性, 和最终生成的可访问性和JavaScript无关.</p>\n</blockquote>\n<h3>推荐文档</h3>\n<p><a href=\"http://www.typescriptlang.org/\">TypeScript 官方文档</a>\n<a href=\"https://www.tslang.cn/docs/tutorial.html\">TypeScript 中文文档</a>\n<a href=\"https://github.com/HerringtonDarkholme/typescript-repl\">TSUN</a></p>\n</div>",
    "title": "typescript up and running",
    "last_reply_at": "2017-06-01T07:34:21.872Z",
    "good": false,
    "top": false,
    "reply_count": 0,
    "visit_count": 69,
    "create_at": "2017-06-01T07:34:21.872Z",
    "author": {
      "loginname": "dawnyoung",
      "avatar_url": "//gravatar.com/avatar/4c847a29bd410e7963bd1dd1a1e637ea?size=48"
    }
  }]
}
